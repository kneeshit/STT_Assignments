diff --git a/src/handle.rs b/src/handle.rs
index ae27e8c..35d312a 100644
--- a/src/handle.rs
+++ b/src/handle.rs
@@ -2,7 +2,8 @@ use std::{ops::Not, path::PathBuf};
 
 use crate::args::ServeArgs;
 
-pub(super) async fn run_serve(mut args: ServeArgs) -> anyhow::Result<()> {
+#[tokio::main]
+pub(super) async fn serve(mut args: ServeArgs) -> anyhow::Result<()> {
     env_logger::init_from_env(env_logger::Env::default());
     if let Some(config_path) = args.config {
         log::info!("Using config file: {}", config_path.display());
@@ -45,13 +46,128 @@ pub(super) async fn run_serve(mut args: ServeArgs) -> anyhow::Result<()> {
     builder.build()?.run().await
 }
 
-pub(super) async fn generate_template(cover: bool, out: Option<PathBuf>) -> anyhow::Result<()> {
+#[cfg(target_family = "unix")]
+pub(super) fn serve_start(args: ServeArgs) -> anyhow::Result<()> {
+    use crate::env::{self, check_root, get_pid};
+    use daemonize::Daemonize;
+    use std::{
+        fs::{File, Permissions},
+        os::unix::prelude::PermissionsExt,
+    };
+
+    check_root();
+
+    if let Some(pid) = get_pid() {
+        println!("OpenGPT is already running with pid: {}", pid);
+        return Ok(());
+    }
+
+    let pid_file = File::create(env::PID_PATH).unwrap();
+    pid_file.set_permissions(Permissions::from_mode(0o755))?;
+
+    let stdout = File::create(env::DEFAULT_STDOUT_PATH).unwrap();
+    stdout.set_permissions(Permissions::from_mode(0o755))?;
+
+    let stderr = File::create(env::DEFAULT_STDERR_PATH).unwrap();
+    stdout.set_permissions(Permissions::from_mode(0o755))?;
+
+    let mut daemonize = Daemonize::new()
+        .pid_file(env::PID_PATH) // Every method except `new` and `start`
+        .chown_pid_file(true) // is optional, see `Daemonize` documentation
+        .working_directory(env::DEFAULT_WORK_DIR) // for default behaviour.
+        .umask(0o777) // Set umask, `0o027` by default.
+        .stdout(stdout) // Redirect stdout to `/tmp/daemon.out`.
+        .stderr(stderr) // Redirect stderr to `/tmp/daemon.err`.
+        .privileged_action(|| "Executed before drop privileges");
+
+    match std::env::var("SUDO_USER") {
+        Ok(user) => {
+            if let Ok(Some(real_user)) = nix::unistd::User::from_name(&user) {
+                daemonize = daemonize
+                    .user(real_user.name.as_str())
+                    .group(real_user.gid.as_raw());
+            }
+        }
+        Err(_) => println!("Could not interpret SUDO_USER"),
+    }
+
+    match daemonize.start() {
+        Ok(_) => println!("Success, daemonized"),
+        Err(e) => eprintln!("Error, {}", e),
+    }
+
+    serve(args)
+}
+
+#[cfg(target_family = "unix")]
+pub(super) fn serve_stop() -> anyhow::Result<()> {
+    use crate::env::{self, check_root, get_pid};
+    use nix::sys::signal;
+    use nix::unistd::Pid;
+
+    check_root();
+
+    if let Some(pid) = get_pid() {
+        if nix::sys::signal::kill(Pid::from_raw(pid.parse::<i32>()?), signal::SIGINT).is_ok() {
+            std::fs::remove_file(env::PID_PATH)?;
+        }
+    } else {
+        println!("OpenGPT is not running")
+    };
+
+    Ok(())
+}
+
+#[cfg(target_family = "unix")]
+pub(super) fn serve_restart(args: ServeArgs) -> anyhow::Result<()> {
+    use crate::env::check_root;
+
+    check_root();
+    println!("Restarting OpenGPT...");
+    serve_stop()?;
+    serve_start(args)
+}
+
+#[cfg(target_family = "unix")]
+pub(super) fn serve_status() -> anyhow::Result<()> {
+    use crate::env::get_pid;
+    if let Some(pid) = get_pid() {
+        println!("OpenGPT is running with pid: {}", pid);
+    } else {
+        println!("OpenGPT is not running")
+    }
+    Ok(())
+}
+
+#[cfg(target_family = "unix")]
+pub(super) fn serve_log() -> anyhow::Result<()> {
+    use crate::env;
+    use std::{
+        fs::File,
+        io::{self, BufRead},
+        path::Path,
+    };
+
+    let path = Path::new(env::DEFAULT_STDERR_PATH); // 请用你的日志文件路径替换
+    let file = File::open(&path)?;
+    let reader = io::BufReader::new(file);
+
+    for line in reader.lines() {
+        match line {
+            Ok(content) => println!("{}", content),
+            Err(err) => eprintln!("Error reading line: {}", err),
+        }
+    }
+    Ok(())
+}
+
+pub(super) fn generate_template(cover: bool, out: Option<PathBuf>) -> anyhow::Result<()> {
     let out = if let Some(out) = out {
         match out.is_dir() {
             false => {
                 if let Some(parent) = out.parent() {
                     if parent.exists().not() {
-                        tokio::fs::create_dir_all(parent).await?;
+                        std::fs::create_dir_all(parent)?;
                     }
                 }
             }
@@ -69,16 +185,13 @@ pub(super) async fn generate_template(cover: bool, out: Option<PathBuf>) -> anyh
         {
             use std::fs::Permissions;
             use std::os::unix::prelude::PermissionsExt;
-            tokio::fs::File::create(&out)
-                .await?
-                .set_permissions(Permissions::from_mode(0o755))
-                .await?;
+            std::fs::File::create(&out)?.set_permissions(Permissions::from_mode(0o755))?;
         }
 
         #[cfg(target_family = "windows")]
-        tokio::fs::File::create(&out).await?;
+        std::fs::File::create(&out)?;
 
-        Ok(tokio::fs::write(out, template).await?)
+        Ok(std::fs::write(out, template)?)
     } else {
         Ok(())
     }
