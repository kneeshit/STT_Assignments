diff --git a/fficall/src/lib.rs b/fficall/src/lib.rs
index e8f67c0..272f3e4 100644
--- a/fficall/src/lib.rs
+++ b/fficall/src/lib.rs
@@ -4,9 +4,16 @@ pub mod model;
 use std::ffi::CString;
 
 use model::{RequestPayload, ResponsePayload};
+use serde::de::DeserializeOwned;
 
 pub type FiiCallResult<T, E = anyhow::Error> = anyhow::Result<T, E>;
 
+pub trait StreamLine: Sync + Send {
+    fn next<T: DeserializeOwned>(self) -> FiiCallResult<Option<T>>;
+
+    fn stop(self) -> FiiCallResult<()>;
+}
+
 #[derive(thiserror::Error, Debug)]
 pub enum SerdeError {
     #[error("failed serialize")]
@@ -15,32 +22,32 @@ pub enum SerdeError {
     DeserializeError,
 }
 
-pub fn call_request(payload: RequestPayload) -> FiiCallResult<ResponsePayload> {
-    let str = serde_json::to_string(&payload)?;
-    let c_str = CString::new(str)?;
+pub fn request(payload: RequestPayload) -> FiiCallResult<ResponsePayload> {
+    let payload = serde_json::to_string(&payload)?;
     let body_utf8 = unsafe {
-        let c_char = ffi::Request(c_str.into_raw());
-        let body_c_char = CString::from_raw(c_char);
-        let body_utf8 = body_c_char.to_bytes().to_vec();
-        drop(body_c_char);
+        let raw_payload = CString::new(payload)?.into_raw();
+        let raw_body = ffi::Request(raw_payload);
+        // release memory
+        let _ = CString::from_raw(raw_payload);
+        let body = CString::from_raw(raw_body);
+        let body_utf8 = body.to_bytes().to_vec();
         body_utf8
     };
 
-    log::debug!(
-        "[gohttp] call_request body: {}",
-        String::from_utf8(body_utf8.to_vec())?
-    );
     Ok(serde_json::from_slice::<model::ResponsePayload>(
         &body_utf8,
     )?)
 }
 
-pub fn call_request_stream(payload: RequestPayload) -> FiiCallResult<ResponsePayload> {
+pub fn request_stream(payload: RequestPayload) -> FiiCallResult<ResponsePayload> {
     let payload = serde_json::to_string(&payload)?;
     let body_utf8 = unsafe {
-        let body_c_char = CString::from_raw(ffi::RequestStream(CString::new(payload)?.into_raw()));
-        let body_utf8 = body_c_char.to_bytes().to_vec();
-        drop(body_c_char);
+        let raw_payload = CString::new(payload)?.into_raw();
+        let raw_body = ffi::RequestStream(raw_payload);
+        // release memory
+        let _ = CString::from_raw(raw_payload);
+        let body = CString::from_raw(raw_body);
+        let body_utf8 = body.to_bytes().to_vec();
         body_utf8
     };
     Ok(serde_json::from_slice::<ResponsePayload>(&body_utf8)?)
