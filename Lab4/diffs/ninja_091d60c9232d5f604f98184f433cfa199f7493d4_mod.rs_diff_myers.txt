diff --git a/openai/src/serve/preauth/mod.rs b/openai/src/serve/preauth/mod.rs
index 68414ad..3c7e303 100644
--- a/openai/src/serve/preauth/mod.rs
+++ b/openai/src/serve/preauth/mod.rs
@@ -1,6 +1,7 @@
 use std::{fs, net::SocketAddr, path::PathBuf};
 
-use http::{header, Request, Response};
+use anyhow::Context;
+use http::{header, Request, Response, Uri};
 use hyper::Body;
 use hyper_proxy::Intercept;
 
@@ -21,28 +22,37 @@ pub(super) async fn mitm_proxy(
     key: PathBuf,
 ) -> anyhow::Result<()> {
     info!("PreAuth CA Private key use: {}", key.display());
-    let private_key_bytes = fs::read(key).expect("ca private key file path not valid!");
+    let private_key_bytes = fs::read(key).context("ca private key file path not valid!")?;
     let private_key = rustls_pemfile::pkcs8_private_keys(&mut private_key_bytes.as_slice())
-        .expect("Failed to parse private key");
+        .context("Failed to parse private key")?;
     let key = rustls::PrivateKey(private_key[0].clone());
 
     info!("PreAuth CA Certificate use: {}", cert.display());
-    let ca_cert_bytes = fs::read(cert).expect("ca cert file path not valid!");
+    let ca_cert_bytes = fs::read(cert).context("ca cert file path not valid!")?;
     let ca_cert = rustls_pemfile::certs(&mut ca_cert_bytes.as_slice())
-        .expect("Failed to parse CA certificate");
+        .context("Failed to parse CA certificate")?;
     let cert = rustls::Certificate(ca_cert[0].clone());
 
     let ca = CertificateAuthority::new(
         key,
         cert,
-        String::from_utf8(ca_cert_bytes).expect("Failed to parse CA certificate"),
+        String::from_utf8(ca_cert_bytes).context("Failed to parse CA certificate")?,
         1_000,
     )
-    .expect("Failed to create Certificate Authority");
+    .context("Failed to create Certificate Authority")?;
+
+    let upstream_proxy = if let Some(ref p) = upstream_proxy {
+        let proxy = hyper_proxy::Proxy::new(
+            Intercept::All,
+            p.parse::<Uri>()
+                .context("Failed to parse upstream proxy address")?,
+        );
+        info!("PreAuth Http MITM Proxy use upstream proxy: {p}");
+        Some(proxy)
+    } else {
+        None
+    };
 
-    if let Some(ref p) = upstream_proxy {
-        info!("PreAuth Http MITM Proxy use upstream proxy: {p}")
-    }
     info!("PreAuth Http MITM Proxy listen on: http://{bind}");
 
     let http_handler = PreAuthHanlder;
@@ -50,14 +60,7 @@ pub(super) async fn mitm_proxy(
     let proxy = proxy::Proxy::builder()
         .ca(ca.clone())
         .listen_addr(bind)
-        .upstream_proxy(upstream_proxy.map(|proxy| {
-            hyper_proxy::Proxy::new(
-                Intercept::All,
-                proxy
-                    .parse()
-                    .expect("Failed to parse upstream proxy address"),
-            )
-        }))
+        .upstream_proxy(upstream_proxy)
         .mitm_filters(vec![String::from("ios.chat.openai.com")])
         .handler(http_handler.clone())
         .build();
@@ -101,19 +104,9 @@ fn collect_preauth_cookie(headers: &http::HeaderMap<http::HeaderValue>) {
         .iter()
         .filter(|(k, _)| k.eq(&header::COOKIE) || k.eq(&header::SET_COOKIE))
         .for_each(|(_, v)| {
-            v.to_str().ok().and_then(|value| {
-                value.find("_preauth_devicecheck").map(|index| {
-                    let preauth_devicecheck =
-                        &value[index + "_preauth_devicecheck=".len()..].trim();
-                    preauth_devicecheck.find(":").map(|colon_index| {
-                        let user_id = &preauth_devicecheck[..colon_index];
-                        context::get_instance().push_preauth_cookie(
-                            user_id.to_owned(),
-                            preauth_devicecheck.to_string(),
-                        )
-                    })
-                })
-            });
+            let _ = v
+                .to_str()
+                .map(|value| context::get_instance().push_preauth_cookie(value));
         });
 }
 
