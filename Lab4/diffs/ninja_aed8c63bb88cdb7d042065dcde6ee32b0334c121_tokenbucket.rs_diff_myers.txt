diff --git a/openai/src/serve/tokenbucket.rs b/openai/src/serve/tokenbucket.rs
index d60c69c..ae36351 100644
--- a/openai/src/serve/tokenbucket.rs
+++ b/openai/src/serve/tokenbucket.rs
@@ -10,20 +10,22 @@ struct BucketState {
 }
 
 pub struct TokenBucket {
+    enable: bool,
     // token bucket capacity `capacity`
     capacity: u32,
     /// token bucket fill rate `fill_rate`
     fill_rate: u32,
-    // ip -> token backet
+    /// ip -> token backet
     buckets: Arc<Mutex<HashMap<IpAddr, BucketState>>>,
-    _cleanup_task: tokio::task::JoinHandle<()>,
+    _cleanup_task: Option<tokio::task::JoinHandle<()>>,
 }
 
 impl TokenBucket {
-    pub fn new(capacity: u32, fill_rate: u32, expired: u32) -> Self {
+    pub fn new(enable: bool, capacity: u32, fill_rate: u32, expired: u32) -> Self {
         let buckets: Arc<Mutex<HashMap<IpAddr, BucketState>>> =
             Arc::new(Mutex::new(HashMap::new()));
         let b = buckets.clone();
+        let task = if enable {
             let task = tokio::task::spawn(async move {
                 loop {
                     tokio::time::sleep(std::time::Duration::from_secs(expired.into())).await;
@@ -33,7 +35,12 @@ impl TokenBucket {
                     drop(b)
                 }
             });
+            Some(task)
+        } else {
+            None
+        };
         Self {
+            enable,
             capacity,
             fill_rate,
             buckets,
@@ -42,6 +49,9 @@ impl TokenBucket {
     }
 
     pub async fn acquire(&self, ip: IpAddr) -> bool {
+        if !self.enable {
+            return true;
+        }
         let mut buckets = self.buckets.lock().await;
         let now = Instant::now();
 
