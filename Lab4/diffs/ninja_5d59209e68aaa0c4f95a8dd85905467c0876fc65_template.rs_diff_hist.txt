diff --git a/openai/src/serve/template.rs b/openai/src/serve/template.rs
index 2d43e38..05fbb4d 100644
--- a/openai/src/serve/template.rs
+++ b/openai/src/serve/template.rs
@@ -9,9 +9,10 @@ use actix_web::{
 use chrono::prelude::{DateTime, Utc};
 use chrono::NaiveDateTime;
 
-use serde_json::json;
+use serde_json::{json, Value};
+
+use crate::{auth, URL_CHATGPT_API};
 
-use crate::auth;
 include!(concat!(env!("OUT_DIR"), "/generated.rs"));
 
 const SESSION_ID: &str = "opengpt_session";
@@ -19,9 +20,9 @@ const BUILD_ID: &str = "WLHd8p-1ysAW_5sZZPJIy";
 const TEMP_404: &str = "404.htm";
 const TEMP_AUTH: &str = "auth.htm";
 const TEMP_CHAT: &str = "chat.htm";
-const TEMP_DETAIL: &str = "detail.html";
-const TEMP_LOGIN: &str = "login.html";
-const TEMP_SHARE: &str = "share.html";
+const TEMP_DETAIL: &str = "detail.htm";
+const TEMP_LOGIN: &str = "login.htm";
+const TEMP_SHARE: &str = "share.htm";
 
 #[allow(dead_code)]
 struct Session<'a> {
@@ -40,7 +41,6 @@ async fn get_static_resource(
     path: web::Path<String>,
 ) -> impl Responder {
     let path = path.into_inner();
-    println!("{}", path);
     match resource_map.iter().find(|(k, _v)| k.contains(&path)) {
         Some((_, v)) => HttpResponse::Ok().content_type(v.mime_type).body(v.data),
         None => HttpResponse::NotFound().finish(),
@@ -53,10 +53,10 @@ pub fn config(cfg: &mut web::ServiceConfig) {
     tera.add_raw_templates(vec![
         (TEMP_404, include_str!("../../templates/404.htm")),
         (TEMP_AUTH, include_str!("../../templates/auth.htm")),
-        (TEMP_LOGIN, include_str!("../../templates/login.html")),
+        (TEMP_LOGIN, include_str!("../../templates/login.htm")),
         (TEMP_CHAT, include_str!("../../templates/chat.htm")),
         (TEMP_DETAIL, include_str!("../../templates/detail.htm")),
-        (TEMP_SHARE, include_str!("../../templates/share.html")),
+        (TEMP_SHARE, include_str!("../../templates/share.htm")),
     ])
     .expect("The static template failed to load");
     cfg.app_data(web::Data::new(tera))
@@ -66,10 +66,6 @@ pub fn config(cfg: &mut web::ServiceConfig) {
         .route("/login", web::post().to(post_login))
         .route("/auth/logout", web::get().to(get_logout))
         .route("/api/auth/session", web::get().to(get_session))
-        .route(
-            "/auth/accounts/check/v4-2023-04-27",
-            web::get().to(get_account_check),
-        )
         .route("/", web::get().to(get_chat))
         .route("/c", web::get().to(get_chat))
         .route("/c/{conversation_id}", web::get().to(get_chat))
@@ -77,16 +73,27 @@ pub fn config(cfg: &mut web::ServiceConfig) {
         .service(web::redirect("/chat/{conversation_id}", "/"))
         .route("/share/{share_id}", web::get().to(get_share_chat))
         .route(
-            &format!("/_next/data/{BUILD_ID}/index.json"),
+            "/_next/data/WLHd8p-1ysAW_5sZZPJIy/index.json",
             web::get().to(get_chat_info),
         )
         .route(
-            &format!(
-                "/_next/data/{BUILD_ID}/c/{}",
-                "{filename:.+\\.(png|js|css|webp|json)}"
-            ),
+            "/_next/data/WLHd8p-1ysAW_5sZZPJIy/c/{conversation_id}.json",
             web::get().to(get_chat_info),
         )
+        .route(
+            "/share/{share_id}/continue",
+            web::get().to(get_share_chat_continue),
+        )
+        .route(
+            "/_next/data/WLHd8p-1ysAW_5sZZPJIy/share/{share_id}.json",
+            web::get().to(get_share_chat_info),
+        )
+        .route(
+            "/_next/data/WLHd8p-1ysAW_5sZZPJIy/share/{share_id}/continue.json",
+            web::get().to(get_share_chat_continue_info),
+        )
+        // user picture
+        .route("/_next/image", web::get().to(get_image))
         // static resource endpoints
         .route(
             "/{filename:.+\\.(png|js|css|webp|json)}",
@@ -97,7 +104,7 @@ pub fn config(cfg: &mut web::ServiceConfig) {
         .route("/ulp/{tail:.*}", web::to(get_static_resource))
         .route("/sweetalert2/{tail:.*}", web::to(get_static_resource))
         // 404 endpoint
-        .default_service(web::route().to(error_404));
+        .default_service(web::route().to(get_error_404));
 }
 
 async fn get_auth(tmpl: web::Data<tera::Tera>) -> Result<HttpResponse> {
@@ -123,18 +130,18 @@ async fn post_login(
     let default_next = "/".to_owned();
     let next = query.get("next").unwrap_or(&default_next);
     let account = account.into_inner();
-    match super::oauth_client().do_access_token(&account).await {
+    match super::auth_client().do_access_token(&account).await {
         Ok(access_token) => HttpResponse::SeeOther()
-            .append_header((header::LOCATION, next.as_str()))
             .cookie(
                 Cookie::build(SESSION_ID, access_token.access_token)
-                    .path("/")
+                    .path(next)
                     .max_age(cookie::time::Duration::seconds(access_token.expires_in))
                     .same_site(cookie::SameSite::Lax)
                     .secure(false)
                     .http_only(true)
                     .finish(),
             )
+            .append_header((header::LOCATION, next.to_owned()))
             .finish(),
         Err(e) => {
             let mut ctx = tera::Context::new();
@@ -177,7 +184,7 @@ async fn login_token(req: HttpRequest) -> Result<HttpResponse> {
 async fn get_logout(req: HttpRequest) -> impl Responder {
     match req.cookie(SESSION_ID) {
         Some(cookie) => {
-            let _ = super::oauth_client().do_revoke_token(cookie.value()).await;
+            let _ = super::auth_client().do_revoke_token(cookie.value()).await;
         }
         None => {}
     }
@@ -200,11 +207,6 @@ async fn get_session(req: HttpRequest) -> Result<HttpResponse> {
                 let profile =
                     token_profile.ok_or(error::ErrorInternalServerError("Get Profile Erorr"))?;
 
-                let session = super::oauth_client()
-                    .do_dashboard_login(cookie.value())
-                    .await
-                    .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
-
                 let dt = DateTime::<Utc>::from_utc(
                     NaiveDateTime::from_timestamp_opt(profile.expires_at(), 0).unwrap(),
                     Utc,
@@ -215,8 +217,8 @@ async fn get_session(req: HttpRequest) -> Result<HttpResponse> {
                         "id": profile.user_id(),
                         "name": profile.email(),
                         "email": profile.email(),
-                        "image": session.picture(),
-                        "picture": session.picture(),
+                        "image": "",
+                        "picture": "",
                         "groups": [],
                     },
                     "expires" : dt.naive_utc(),
@@ -232,66 +234,6 @@ async fn get_session(req: HttpRequest) -> Result<HttpResponse> {
     }
 }
 
-async fn get_account_check() -> impl Responder {
-    let res = serde_json::json!({
-        "accounts": {
-            "default": {
-                "account": {
-                    "account_user_role": "account-owner",
-                    "account_user_id": "d0322341-7ace-4484-b3f7-89b03e82b927",
-                    "processor": {
-                        "a001": {
-                            "has_customer_object": true
-                        },
-                        "b001": {
-                            "has_transaction_history": true
-                        }
-                    },
-                    "account_id": "a323bd05-db25-4e8f-9173-2f0c228cc8fa",
-                    "is_most_recent_expired_subscription_gratis": true,
-                    "has_previously_paid_subscription": true
-                },
-                "features": [
-                    "model_switcher",
-                    "model_preview",
-                    "system_message",
-                    "data_controls_enabled",
-                    "data_export_enabled",
-                    "show_existing_user_age_confirmation_modal",
-                    "bucketed_history",
-                    "priority_driven_models_list",
-                    "message_style_202305",
-                    "layout_may_2023",
-                    "plugins_available",
-                    "beta_features",
-                    "infinite_scroll_history",
-                    "browsing_available",
-                    "browsing_inner_monologue",
-                    "browsing_bing_branding",
-                    "shareable_links",
-                    "plugin_display_params",
-                    "tools3_dev",
-                    "tools2",
-                    "debug",
-                ],
-                "entitlement": {
-                    "subscription_id": "d0dcb1fc-56aa-4cd9-90ef-37f1e03576d3",
-                    "has_active_subscription": true,
-                    "subscription_plan": "chatgptplusplan",
-                    "expires_at": "2089-08-08T23:59:59+00:00"
-                },
-                "last_active_subscription": {
-                    "subscription_id": "d0dcb1fc-56aa-4cd9-90ef-37f1e03576d3",
-                    "purchase_origin_platform": "chatgpt_mobile_ios",
-                    "will_renew": true
-                }
-            }
-        },
-        "temp_ap_available_at": "2023-05-20T17:30:00+00:00"
-    });
-    HttpResponse::Ok().json(res)
-}
-
 async fn get_chat(
     tmpl: web::Data<tera::Tera>,
     req: HttpRequest,
@@ -397,14 +339,63 @@ async fn get_chat_info(req: HttpRequest) -> Result<HttpResponse> {
 async fn get_share_chat(
     tmpl: web::Data<tera::Tera>,
     req: HttpRequest,
-    mut query: web::Query<HashMap<String, String>>,
     share_id: web::Path<String>,
 ) -> Result<HttpResponse> {
     let share_id = share_id.into_inner();
     match req.cookie(SESSION_ID) {
         Some(cookie) => match crate::token::verify_access_token(cookie.value()).await {
             Ok(_) => {
-                query.insert("chatId".to_string(), share_id);
+                let resp = super::client()
+                    .get(format!("{URL_CHATGPT_API}/backend-api/share/{share_id}"))
+                    .bearer_auth(cookie.value())
+                    .send()
+                    .await
+                    .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
+
+                match resp.json::<Value>().await {
+                    Ok(mut share_data) => {
+                        if let Some(replace) = share_data
+                            .get_mut("continue_conversation_url")
+                            .and_then(|v| v.as_str())
+                        {
+                            let new_value = replace.replace("https://chat.openai.com", "");
+                            share_data.as_object_mut().and_then(|data| {
+                                data.insert(
+                                    "continue_conversation_url".to_owned(),
+                                    json!(new_value),
+                                )
+                            });
+                        }
+
+                        let props = serde_json::json!({
+                                    "props": {
+                                        "pageProps": {
+                                            "sharedConversationId": share_id,
+                                            "serverResponse": {
+                                                "type": "data",
+                                                "data": share_data
+                                            },
+                                            "continueMode": false,
+                                            "moderationMode": false,
+                                            "chatPageProps": {},
+                                        },
+                                        "__N_SSP": true
+                                    },
+                                    "page": "/share/[[...shareParams]]",
+                                    "query": {
+                                        "shareParams": vec![share_id]
+                                    },
+                                    "buildId": BUILD_ID,
+                                    "isFallback": false,
+                                    "gssp": true,
+                                    "scriptLoader": []
+                                }
+                        );
+                        let mut ctx = tera::Context::new();
+                        ctx.insert("props", &props.to_string());
+                        render_template(tmpl, TEMP_SHARE, &ctx)
+                    }
+                    Err(_) => {
                         let props = serde_json::json!({
                             "props": {
                                 "pageProps": {"statusCode": 404}
@@ -420,7 +411,9 @@ async fn get_share_chat(
 
                         let mut ctx = tera::Context::new();
                         ctx.insert("props", &props.to_string());
-                render_template(tmpl, TEMP_SHARE, &ctx)
+                        render_template(tmpl, TEMP_404, &ctx)
+                    }
+                }
             }
             Err(_) => Ok(HttpResponse::Found()
                 .insert_header((
@@ -433,7 +426,183 @@ async fn get_share_chat(
     }
 }
 
-async fn error_404(tmpl: web::Data<tera::Tera>) -> Result<HttpResponse> {
+async fn get_share_chat_info(
+    req: HttpRequest,
+    share_id: web::Path<String>,
+) -> Result<HttpResponse> {
+    let share_id = share_id.into_inner();
+    match req.cookie(SESSION_ID) {
+        Some(cookie) => match crate::token::verify_access_token(cookie.value()).await {
+            Ok(_) => {
+                let resp = super::client()
+                    .get(format!("{URL_CHATGPT_API}/backend-api/share/{share_id}"))
+                    .bearer_auth(cookie.value())
+                    .send()
+                    .await
+                    .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
+
+                match resp.json::<Value>().await {
+                    Ok(mut share_data) => {
+                        if let Some(replace) = share_data
+                            .get_mut("continue_conversation_url")
+                            .and_then(|v| v.as_str())
+                        {
+                            let new_value = replace.replace("https://chat.openai.com", "");
+                            share_data.as_object_mut().and_then(|data| {
+                                data.insert(
+                                    "continue_conversation_url".to_owned(),
+                                    json!(new_value),
+                                )
+                            });
+                        }
+
+                        let props = serde_json::json!({
+                            "pageProps": {
+                                "sharedConversationId": share_id,
+                                "serverResponse": {
+                                    "type": "data",
+                                    "data": share_data,
+                                },
+                                "continueMode": false,
+                                "moderationMode": false,
+                                "chatPageProps": {},
+                            },
+                            "__N_SSP": true
+                        }
+                        );
+                        Ok(HttpResponse::Ok().json(props))
+                    }
+                    Err(_) => Ok(HttpResponse::Ok().json(serde_json::json!({"notFound": true}))),
+                }
+            }
+            Err(_) => Ok(HttpResponse::Found()
+                .insert_header((
+                    header::LOCATION,
+                    format!("/login?next=%2Fshare%2F{share_id}"),
+                ))
+                .finish()),
+        },
+        None => redirect_login(),
+    }
+}
+
+async fn get_share_chat_continue(share_id: web::Path<String>) -> Result<HttpResponse> {
+    Ok(HttpResponse::PermanentRedirect()
+        .insert_header((
+            header::LOCATION,
+            format!("/share/{}", share_id.into_inner()),
+        ))
+        .finish())
+}
+
+async fn get_share_chat_continue_info(
+    req: HttpRequest,
+    share_id: web::Path<String>,
+) -> Result<HttpResponse> {
+    match req.cookie(SESSION_ID) {
+        Some(cookie) => match crate::token::verify_access_token(cookie.value()).await {
+            Ok(token_profile) => {
+                let profile =
+                    token_profile.ok_or(error::ErrorInternalServerError("Get Profile Erorr"))?;
+                    let resp = super::client()
+                    .get(format!("{URL_CHATGPT_API}/backend-api/share/{share_id}"))
+                    .bearer_auth(cookie.value())
+                    .send()
+                    .await
+                    .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
+
+                match resp.json::<Value>().await {
+                    Ok(mut share_data) => {
+                        if let Some(replace) = share_data
+                            .get_mut("continue_conversation_url")
+                            .and_then(|v| v.as_str())
+                        {
+                            let new_value = replace.replace("https://chat.openai.com", "");
+                            share_data.as_object_mut().and_then(|data| {
+                                data.insert(
+                                    "continue_conversation_url".to_owned(),
+                                    json!(new_value),
+                                )
+                            });
+                        }
+
+                        let props = serde_json::json!({
+                                "pageProps": {
+                                    "user": {
+                                        "id": profile.user_id(),
+                                        "name": profile.email(),
+                                        "email": profile.email(),
+                                        "image": None::<String>,
+                                        "picture": None::<String>,
+                                        "groups": [],
+                                    },
+                                    "serviceStatus": {},
+                                    "userCountry": "US",
+                                    "geoOk": true,
+                                    "serviceAnnouncement": {
+                                        "paid": {},
+                                        "public": {}
+                                    },
+                                    "isUserInCanPayGroup": true,
+                                    "sharedConversationId": share_id.into_inner(),
+                                    "serverResponse": {
+                                        "type": "data",
+                                        "data": share_data,
+                                    },
+                                    "continueMode": true,
+                                    "moderationMode": false,
+                                    "chatPageProps": {
+                                        "user": {
+                                            "id": profile.user_id(),
+                                            "name": profile.email(),
+                                            "email": profile.email(),
+                                            "image": None::<String>,
+                                            "picture": None::<String>,
+                                            "groups": [],
+                                        },
+                                        "serviceStatus": {},
+                                        "userCountry": "US",
+                                        "geoOk": true,
+                                        "serviceAnnouncement": {
+                                            "paid": {},
+                                            "public": {}
+                                        },
+                                        "isUserInCanPayGroup": true,
+                                    },
+                                },
+                                "__N_SSP": true
+                            });
+                        Ok(HttpResponse::Ok().json(props))
+                    }
+                    Err(_) => Ok(HttpResponse::Ok()
+                    .append_header(("referrer-policy", "same-origin"))
+                    .json(serde_json::json!({"notFound": true}))),
+                }
+            }
+            Err(_) => {
+                Ok(HttpResponse::TemporaryRedirect()
+                .json(serde_json::json!({
+                    "pageProps": {
+                        "__N_REDIRECT": format!("/auth/login?next=%2Fshare%2F{}%2Fcontinue", share_id.into_inner()),
+                        "__N_REDIRECT_STATUS": 307
+                    },
+                    "__N_SSP": true
+                })))
+            }
+        },
+        None => {
+            redirect_login()
+        },
+    }
+}
+
+async fn get_image(params: Option<web::Query<ImageQuery>>) -> Result<HttpResponse> {
+    let query = params.ok_or(error::ErrorBadRequest("Missing URL parameter"))?;
+    let resp = super::client().get(&query.url).send().await;
+    Ok(super::response_handle(resp))
+}
+
+async fn get_error_404(tmpl: web::Data<tera::Tera>) -> Result<HttpResponse> {
     let mut ctx = tera::Context::new();
     let props = json!(
         {
@@ -475,3 +644,11 @@ fn render_template(
         .content_type(header::ContentType::html())
         .body(tm))
 }
+
+#[allow(dead_code)]
+#[derive(serde::Deserialize)]
+struct ImageQuery {
+    url: String,
+    w: String,
+    q: String,
+}
