diff --git a/openai/src/serve/ui.rs b/openai/src/serve/ui.rs
index bbf1634..1e7d08e 100644
--- a/openai/src/serve/ui.rs
+++ b/openai/src/serve/ui.rs
@@ -1,28 +1,46 @@
 use std::collections::HashMap;
+use std::net::IpAddr;
+use std::net::SocketAddr;
 use std::sync::Once;
 
-use actix_web::cookie;
-use actix_web::{
-    cookie::Cookie, error, http::header, web, HttpRequest, HttpResponse, Responder, Result,
-};
+use anyhow::anyhow;
+use axum::body::Body;
+use axum::body::StreamBody;
+use axum::extract::ConnectInfo;
+use axum::extract::Path;
+use axum::extract::Query;
+use axum::http::header;
+use axum::http::HeaderMap;
+use axum::http::Response;
+use axum::routing::any;
+use axum::routing::{get, post};
+use axum::Router;
+use axum_extra::extract::cookie;
+use axum_extra::extract::CookieJar;
+
 use base64::Engine;
 use chrono::NaiveDateTime;
 use chrono::{prelude::DateTime, Utc};
 
+use axum::http::StatusCode;
 use serde::{Deserialize, Serialize};
 use serde_json::{json, Value};
 
+use crate::info;
 use crate::{
     auth::{model::AuthAccount, AuthHandle},
     model::AuthenticateToken,
     URL_CHATGPT_API,
 };
 
-use super::auth_client;
+use super::err::ResponseError;
+use super::EMPTY;
+use super::{auth_client, err};
 
 include!(concat!(env!("OUT_DIR"), "/generated.rs"));
 
 const DEFAULT_INDEX: &str = "/";
+const LOGIN_INDEX: &str = "/auth/login";
 const SESSION_ID: &str = "opengpt_session";
 const BUILD_ID: &str = "XmKrBoPpskgF_4RiIX1jm";
 const TEMP_404: &str = "404.htm";
@@ -37,6 +55,7 @@ static INIT: Once = Once::new();
 pub(super) static mut STATIC_FILES: Option<HashMap<&'static str, static_files::Resource>> = None;
 pub(super) static mut TEMPLATE: Option<tera::Tera> = None;
 pub(super) static mut TEMPLATE_DATA: Option<TemplateData> = None;
+pub(super) static mut DISABLE_UI: bool = false;
 
 #[derive(Serialize, Deserialize)]
 struct Session {
@@ -58,13 +77,13 @@ impl ToString for Session {
 }
 
 impl TryFrom<&str> for Session {
-    type Error = error::Error;
+    type Error = err::ResponseError;
 
     fn try_from(value: &str) -> std::result::Result<Self, Self::Error> {
         let data = base64::engine::general_purpose::URL_SAFE
             .decode(value)
-            .map_err(|err| error::ErrorUnauthorized(err.to_string()))?;
-        serde_json::from_slice(&data).map_err(|err| error::ErrorUnauthorized(err.to_string()))
+            .map_err(|err| err::ResponseError::Unauthorized(err))?;
+        serde_json::from_slice(&data).map_err(|err| err::ResponseError::Unauthorized(err))
     }
 }
 
@@ -101,7 +120,7 @@ pub(super) struct TemplateData {
 impl From<super::Launcher> for TemplateData {
     fn from(value: super::Launcher) -> Self {
         Self {
-            api_prefix: Some(value.api_prefix.unwrap_or("".to_owned())),
+            api_prefix: value.api_prefix,
             cf_site_key: value.cf_site_key,
             cf_secret_key: value.cf_secret_key,
         }
@@ -109,8 +128,11 @@ impl From<super::Launcher> for TemplateData {
 }
 
 // this function could be located in a different module
-pub fn config(cfg: &mut web::ServiceConfig) {
-    if !unsafe { super::DISABLE_UI } {
+pub fn config(router: Router) -> Router {
+    if !unsafe { DISABLE_UI } {
+        if let Some(url) = unsafe { TEMPLATE_DATA.as_ref().unwrap().api_prefix.as_ref() } {
+            info!("WebUI site use api: {url}")
+        }
         let mut tera = tera::Tera::default();
         tera.add_raw_templates(vec![
             (TEMP_404, include_str!("../../ui/404.htm")),
@@ -127,64 +149,78 @@ pub fn config(cfg: &mut web::ServiceConfig) {
             TEMPLATE = Some(tera);
         });
 
-        cfg.route("/auth", web::get().to(get_auth))
-            .route("/auth/login", web::get().to(get_login))
-            .route("/auth/login", web::post().to(post_login))
-            .route("/auth/login/token", web::post().to(post_login_token))
-            .route("/auth/logout", web::get().to(get_logout))
-            .route("/auth/session", web::get().to(get_session))
-            .route("/", web::get().to(get_chat))
-            .route("/c", web::get().to(get_chat))
-            .route("/c/{conversation_id}", web::get().to(get_chat))
-            .service(web::redirect("/chat", "/"))
-            .service(web::redirect("/chat/{conversation_id}", "/"))
-            .route("/share/{share_id}", web::get().to(get_share_chat))
+        router
+            .route("/auth", get(get_auth))
+            .route("/auth/login", get(get_login))
+            .route("/auth/login", post(post_login))
+            .route("/auth/login/token", post(post_login_token))
+            .route("/auth/logout", get(get_logout))
+            .route("/auth/session", get(get_session))
+            .route("/", get(get_chat))
+            .route("/c", get(get_chat))
+            .route("/c/:conversation_id", get(get_chat))
+            .route(
+                "/chat",
+                any(|| async {
+                    Response::builder()
+                        .status(StatusCode::FOUND)
+                        .header(header::LOCATION, "/")
+                        .body(Body::empty())
+                        .unwrap()
+                }),
+            )
             .route(
-                "/share/{share_id}/continue",
-                web::get().to(get_share_chat_continue),
+                "/chat/:conversation_id",
+                any(|| async {
+                    Response::builder()
+                        .status(StatusCode::FOUND)
+                        .header(header::LOCATION, "/")
+                        .body(Body::empty())
+                        .unwrap()
+                }),
             )
+            .route("/share/:share_id", get(get_share_chat))
+            .route("/share/:share_id/continue", get(get_share_chat_continue))
             .route(
                 &format!("/_next/data/{BUILD_ID}/index.json"),
-                web::get().to(get_chat_info),
+                get(get_chat_info),
             )
             .route(
-                &format!("/_next/data/{BUILD_ID}/c/{}.json", "{conversation_id}"),
-                web::get().to(get_chat_info),
+                // {conversation_id}.json
+                &format!("/_next/data/{BUILD_ID}/c/:conversation_id"),
+                get(get_chat_info),
             )
             .route(
-                &format!("/_next/data/{BUILD_ID}/share/{}.json", "{share_id}"),
-                web::get().to(get_share_chat_info),
+                // {share_id}.json
+                &format!("/_next/data/{BUILD_ID}/share/:share_id"),
+                get(get_share_chat_info),
             )
             .route(
-                &format!(
-                    "/_next/data/{BUILD_ID}/share/{}/continue.json",
-                    "{share_id}"
-                ),
-                web::get().to(get_share_chat_continue_info),
+                &format!("/_next/data/{BUILD_ID}/share/:share_id/continue.json"),
+                get(get_share_chat_continue_info),
             )
             // user picture
-            .route("/_next/image", web::get().to(get_image))
+            .route("/_next/image", get(get_image))
             // static resource endpoints
-            .route(
-                "/{filename:.+\\.(png|js|css|webp|json)}",
-                web::get().to(get_static_resource),
-            )
-            .route("/_next/static/{tail:.*}", web::to(get_static_resource))
-            .route("/fonts/{tail:.*}", web::to(get_static_resource))
-            .route("/ulp/{tail:.*}", web::to(get_static_resource))
-            .route("/sweetalert2/{tail:.*}", web::to(get_static_resource))
+            .route("/resources/*path", get(get_static_resource))
+            .route("/_next/static/*path", get(get_static_resource))
+            .route("/fonts/*path", get(get_static_resource))
+            .route("/ulp/*path", get(get_static_resource))
+            .route("/sweetalert2/*path", get(get_static_resource))
             // 404 endpoint
-            .default_service(web::route().to(get_error_404));
+            .fallback(error_404)
+    } else {
+        router
     }
 }
 
-async fn get_auth() -> Result<HttpResponse> {
+async fn get_auth() -> Result<Response<Body>, ResponseError> {
     let mut ctx = tera::Context::new();
     settings_template_data(&mut ctx);
     render_template(TEMP_AUTH, &ctx)
 }
 
-async fn get_login() -> Result<HttpResponse> {
+async fn get_login() -> Result<Response<Body>, ResponseError> {
     let mut ctx = tera::Context::new();
     ctx.insert("error", "");
     ctx.insert("username", "");
@@ -192,34 +228,40 @@ async fn get_login() -> Result<HttpResponse> {
     render_template(TEMP_LOGIN, &ctx)
 }
 
-async fn post_login(req: HttpRequest, account: web::Form<AuthAccount>) -> Result<HttpResponse> {
-    let account = account.into_inner();
-    if let Some(err) = cf_captcha_check(&req, account.cf_turnstile_response.as_deref())
+async fn post_login(
+    ConnectInfo(addr): ConnectInfo<SocketAddr>,
+    account: axum::Form<AuthAccount>,
+) -> Result<Response<Body>, ResponseError> {
+    let account = account.0;
+    if let Some(err) = cf_captcha_check(addr.ip(), account.cf_turnstile_response.as_deref())
         .await
         .err()
     {
         let mut ctx = tera::Context::new();
         ctx.insert("username", &account.username);
-        ctx.insert("error", &err.to_string());
+        ctx.insert("error", &err.msg());
         return render_template(TEMP_LOGIN, &ctx);
     }
     match super::auth_client().do_access_token(&account).await {
         Ok(access_token) => {
             let authentication_token = AuthenticateToken::try_from(access_token)
-                .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
+                .map_err(|err| err::ResponseError::InternalServerError(err))?;
             let session = Session::from(authentication_token);
-            Ok(HttpResponse::SeeOther()
-                .cookie(
-                    Cookie::build(SESSION_ID, session.to_string())
+
+            let cookie = cookie::Cookie::build(SESSION_ID, session.to_string())
                 .path(DEFAULT_INDEX)
-                        .max_age(cookie::time::Duration::seconds(session.expires_in))
                 .same_site(cookie::SameSite::Lax)
+                .max_age(time::Duration::seconds(session.expires_in))
                 .secure(false)
                 .http_only(false)
-                        .finish(),
-                )
-                .append_header((header::LOCATION, DEFAULT_INDEX))
-                .finish())
+                .finish();
+
+            Ok(Response::builder()
+                .status(StatusCode::SEE_OTHER)
+                .header(header::LOCATION, DEFAULT_INDEX)
+                .header(header::SET_COOKIE, cookie.to_string())
+                .body(Body::empty())
+                .map_err(|err| err::ResponseError::InternalServerError(err))?)
         }
         Err(e) => {
             let mut ctx = tera::Context::new();
@@ -230,12 +272,14 @@ async fn post_login(req: HttpRequest, account: web::Form<AuthAccount>) -> Result
     }
 }
 
-async fn post_login_token(req: HttpRequest) -> Result<HttpResponse> {
-    if let Some(token) = req.headers().get(header::AUTHORIZATION) {
+async fn post_login_token(headers: HeaderMap) -> Result<Response<Body>, ResponseError> {
+    if let Some(token) = headers.get(header::AUTHORIZATION) {
         let access_token = token.to_str().unwrap_or_default();
         let profile = crate::token::check(access_token)
-            .map_err(|e| error::ErrorUnauthorized(e.to_string()))?
-            .ok_or(error::ErrorInternalServerError("Get Profile Erorr"))?;
+            .map_err(|err| err::ResponseError::Unauthorized(err))?
+            .ok_or(err::ResponseError::InternalServerError(anyhow!(
+                "Get Profile Erorr"
+            )))?;
 
         let session = match auth_client().do_get_user_picture(access_token).await {
             Ok(picture) => Session {
@@ -258,49 +302,53 @@ async fn post_login_token(req: HttpRequest) -> Result<HttpResponse> {
             },
         };
 
-        return Ok(HttpResponse::Ok()
-            .insert_header((header::LOCATION, DEFAULT_INDEX))
-            .cookie(
-                Cookie::build(SESSION_ID, session.to_string())
+        let cookie = cookie::Cookie::build(SESSION_ID, session.to_string())
             .path(DEFAULT_INDEX)
-                    .max_age(cookie::time::Duration::seconds(session.expires_in))
             .same_site(cookie::SameSite::Lax)
+            .max_age(time::Duration::seconds(session.expires_in))
             .secure(false)
             .http_only(false)
-                    .finish(),
-            )
-            .finish());
+            .finish();
+
+        return Ok(Response::builder()
+            .status(StatusCode::OK)
+            .header(header::LOCATION, DEFAULT_INDEX)
+            .header(header::SET_COOKIE, cookie.to_string())
+            .body(Body::empty())
+            .map_err(|err| err::ResponseError::InternalServerError(err))?);
     }
     redirect_login()
 }
 
-async fn get_logout(req: HttpRequest) -> Result<HttpResponse> {
-    if let Some(c) = req.cookie(SESSION_ID) {
-        match Session::try_from(c.value()) {
+async fn get_logout(jar: CookieJar) -> Result<Response<Body>, ResponseError> {
+    if let Some(c) = jar.get(SESSION_ID) {
+        match extract_session(c.value()) {
             Ok(session) => {
                 if let Some(refresh_token) = session.refresh_token {
-                    let _ = auth_client().do_revoke_token(&refresh_token).await;
+                    let _a = auth_client().do_revoke_token(&refresh_token).await;
                 }
             }
             Err(_) => {}
         }
     }
-    Ok(HttpResponse::SeeOther()
-        .cookie(
-            Cookie::build(SESSION_ID, "")
+    let cookie = cookie::Cookie::build(SESSION_ID, EMPTY)
         .path(DEFAULT_INDEX)
-                .expires(cookie::time::OffsetDateTime::now_utc())
         .same_site(cookie::SameSite::Lax)
+        .max_age(time::Duration::seconds(0))
         .secure(false)
         .http_only(false)
-                .finish(),
-        )
-        .insert_header((header::LOCATION, "/auth/login"))
-        .finish())
+        .finish();
+
+    Ok(Response::builder()
+        .status(StatusCode::FOUND)
+        .header(header::LOCATION, LOGIN_INDEX)
+        .header(header::SET_COOKIE, cookie.to_string())
+        .body(Body::empty())
+        .map_err(|err| err::ResponseError::InternalServerError(err))?)
 }
 
-async fn get_session(req: HttpRequest) -> Result<HttpResponse> {
-    if let Some(cookie) = req.cookie(SESSION_ID) {
+async fn get_session(jar: CookieJar) -> Result<Response<Body>, ResponseError> {
+    if let Some(cookie) = jar.get(SESSION_ID) {
         let session = extract_session(cookie.value())?;
         let dt = DateTime::<Utc>::from_utc(
             NaiveDateTime::from_timestamp_opt(session.expires, 0).unwrap(),
@@ -321,22 +369,27 @@ async fn get_session(req: HttpRequest) -> Result<HttpResponse> {
             "authProvider": "auth0"
         });
 
-        return Ok(HttpResponse::Ok().json(props));
+        return Ok(Response::builder()
+            .status(StatusCode::OK)
+            .header(header::LOCATION, LOGIN_INDEX)
+            .header(header::SET_COOKIE, cookie.to_string())
+            .body(Body::from(props.to_string()))
+            .map_err(|err| err::ResponseError::InternalServerError(err))?);
     }
     redirect_login()
 }
 
 async fn get_chat(
-    req: HttpRequest,
-    conversation_id: Option<web::Path<String>>,
-    mut query: web::Query<HashMap<String, String>>,
-) -> Result<HttpResponse> {
-    if let Some(cookie) = req.cookie(SESSION_ID) {
+    jar: CookieJar,
+    conversation_id: Option<Path<String>>,
+    mut query: Query<HashMap<String, String>>,
+) -> Result<Response<Body>, ResponseError> {
+    if let Some(cookie) = jar.get(SESSION_ID) {
         return match extract_session(cookie.value()) {
             Ok(session) => {
                 let (template_name, path) = match conversation_id {
                     Some(conversation_id) => {
-                        query.insert("chatId".to_string(), conversation_id.into_inner());
+                        query.insert("chatId".to_string(), conversation_id.0);
                         (TEMP_DETAIL, "/c/[chatId]")
                     }
                     None => (TEMP_CHAT, DEFAULT_INDEX),
@@ -364,7 +417,7 @@ async fn get_chat(
                         "__N_SSP": true
                     },
                     "page": path,
-                    "query": query.into_inner(),
+                    "query": query.0,
                     "buildId": BUILD_ID,
                     "isFallback": false,
                     "gssp": true,
@@ -374,7 +427,7 @@ async fn get_chat(
                 ctx.insert(
                     "props",
                     &serde_json::to_string(&props)
-                        .map_err(|e| error::ErrorInternalServerError(e.to_string()))?,
+                        .map_err(|err| err::ResponseError::InternalServerError(err))?,
                 );
                 settings_template_data(&mut ctx);
                 return render_template(template_name, &ctx);
@@ -385,8 +438,8 @@ async fn get_chat(
     redirect_login()
 }
 
-async fn get_chat_info(req: HttpRequest) -> Result<HttpResponse> {
-    if let Some(cookie) = req.cookie(SESSION_ID) {
+async fn get_chat_info(jar: CookieJar) -> Result<Response<Body>, ResponseError> {
+    if let Some(cookie) = jar.get(SESSION_ID) {
         return match extract_session(cookie.value()) {
             Ok(session) => {
                 let body = serde_json::json!({
@@ -411,22 +464,34 @@ async fn get_chat_info(req: HttpRequest) -> Result<HttpResponse> {
                     "__N_SSP": true
                 });
 
-                Ok(HttpResponse::Ok().json(body))
+                Ok(Response::builder()
+                    .status(StatusCode::OK)
+                    .header(header::CONTENT_TYPE, "application/json")
+                    .body(Body::from(body.to_string()))
+                    .map_err(|err| err::ResponseError::InternalServerError(err))?)
             }
             Err(_) => {
                 let body = serde_json::json!(
                     {"pageProps": {"__N_REDIRECT": "/auth/login?", "__N_REDIRECT_STATUS": 307}, "__N_SSP": true}
                 );
-                Ok(HttpResponse::Ok().json(body))
+                Ok(Response::builder()
+                    .status(StatusCode::OK)
+                    .header(header::CONTENT_TYPE, "application/json")
+                    .body(Body::from(body.to_string()))
+                    .map_err(|err| err::ResponseError::InternalServerError(err))?)
             }
         };
     }
-    redirect_login()
+    // redirect_login()
+    todo!()
 }
 
-async fn get_share_chat(req: HttpRequest, share_id: web::Path<String>) -> Result<HttpResponse> {
-    let share_id = share_id.into_inner();
-    if let Some(cookie) = req.cookie(SESSION_ID) {
+async fn get_share_chat(
+    jar: CookieJar,
+    share_id: Path<String>,
+) -> Result<Response<Body>, ResponseError> {
+    let share_id = share_id.0;
+    if let Some(cookie) = jar.get(SESSION_ID) {
         return match extract_session(cookie.value()) {
             Ok(session) => {
                 let url = get_url();
@@ -435,7 +500,7 @@ async fn get_share_chat(req: HttpRequest, share_id: web::Path<String>) -> Result
                     .bearer_auth(session.access_token)
                     .send()
                     .await
-                    .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
+                    .map_err(|err| err::ResponseError::InternalServerError(err))?;
 
                 match resp.json::<Value>().await {
                     Ok(mut share_data) => {
@@ -477,7 +542,7 @@ async fn get_share_chat(req: HttpRequest, share_id: web::Path<String>) -> Result
                                 }
                         );
                         let mut ctx = tera::Context::new();
-                        ctx.insert("props", &props.to_string());
+                        ctx.insert("props", &serde_json::to_string(&props).unwrap());
                         settings_template_data(&mut ctx);
                         render_template(TEMP_SHARE, &ctx)
                     }
@@ -496,30 +561,33 @@ async fn get_share_chat(req: HttpRequest, share_id: web::Path<String>) -> Result
                         });
 
                         let mut ctx = tera::Context::new();
-                        ctx.insert("props", &props.to_string());
+                        ctx.insert("props", &serde_json::to_string(&props).unwrap());
                         settings_template_data(&mut ctx);
                         render_template(TEMP_404, &ctx)
                     }
                 }
             }
-            Err(_) => Ok(HttpResponse::Found()
-                .insert_header((
+            Err(_) => Ok(Response::builder()
+                .status(StatusCode::FOUND)
+                .header(
                     header::LOCATION,
                     format!("/auth/login?next=%2Fshare%2F{share_id}"),
-                ))
-                .finish()),
+                )
+                .body(Body::empty())
+                .map_err(|err| err::ResponseError::InternalServerError(err))?),
         };
     }
 
-    redirect_login()
+    // redirect_login()
+    todo!()
 }
 
 async fn get_share_chat_info(
-    req: HttpRequest,
-    share_id: web::Path<String>,
-) -> Result<HttpResponse> {
-    let share_id = share_id.into_inner();
-    if let Some(cookie) = req.cookie(SESSION_ID) {
+    jar: CookieJar,
+    share_id: Path<String>,
+) -> Result<Response<Body>, ResponseError> {
+    let share_id = share_id.0.replace(".json", "");
+    if let Some(cookie) = jar.get(SESSION_ID) {
         if let Ok(session) = extract_session(cookie.value()) {
             let url = get_url();
             let resp = super::api_client()
@@ -527,7 +595,7 @@ async fn get_share_chat_info(
                 .bearer_auth(session.access_token)
                 .send()
                 .await
-                .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
+                .map_err(|err| err::ResponseError::InternalServerError(err))?;
 
             return match resp.json::<Value>().await {
                 Ok(mut share_data) => {
@@ -555,45 +623,56 @@ async fn get_share_chat_info(
                         "__N_SSP": true
                     }
                     );
-                    Ok(HttpResponse::Ok().json(props))
-                }
-                Err(_) => Ok(HttpResponse::Ok().json(serde_json::json!({"notFound": true}))),
+                    Ok(Response::builder()
+                        .status(StatusCode::OK)
+                        .header(header::CONTENT_TYPE, "applications/json")
+                        .body(Body::from(serde_json::to_string(&props).unwrap()))
+                        .map_err(|err| err::ResponseError::InternalServerError(err))?)
+                }
+                Err(_) => Ok(Response::builder()
+                    .status(StatusCode::OK)
+                    .header(header::CONTENT_TYPE, "applications/json")
+                    .body(Body::from(
+                        serde_json::to_string(&serde_json::json!({"notFound": true})).unwrap(),
+                    ))
+                    .map_err(|err| err::ResponseError::InternalServerError(err))?),
             };
         }
 
-        return Ok(HttpResponse::Found()
-            .insert_header((
+        return Ok(Response::builder()
+            .status(StatusCode::OK)
+            .header(
                 header::LOCATION,
                 format!("/auth/login?next=%2Fshare%2F{share_id}"),
-            ))
-            .finish());
+            )
+            .body(Body::empty())
+            .map_err(|err| err::ResponseError::InternalServerError(err))?);
     }
     redirect_login()
 }
 
-async fn get_share_chat_continue(share_id: web::Path<String>) -> Result<HttpResponse> {
-    Ok(HttpResponse::PermanentRedirect()
-        .insert_header((
-            header::LOCATION,
-            format!("/share/{}", share_id.into_inner()),
-        ))
-        .finish())
+async fn get_share_chat_continue(share_id: Path<String>) -> Result<Response<Body>, ResponseError> {
+    Ok(Response::builder()
+        .status(StatusCode::PERMANENT_REDIRECT)
+        .header(header::LOCATION, format!("/share/{}", share_id.0))
+        .body(Body::empty())
+        .map_err(|err| err::ResponseError::InternalServerError(err))?)
 }
 
 async fn get_share_chat_continue_info(
-    req: HttpRequest,
-    share_id: web::Path<String>,
-) -> Result<HttpResponse> {
-    if let Some(cookie) = req.cookie(SESSION_ID) {
+    jar: CookieJar,
+    share_id: Path<String>,
+) -> Result<Response<Body>, ResponseError> {
+    if let Some(cookie) = jar.get(SESSION_ID) {
         return match extract_session(cookie.value()) {
             Ok(session) => {
                 let url = get_url();
                 let resp = super::api_client()
-                .get(format!("{url}/backend-api/share/{share_id}"))
+                .get(format!("{url}/backend-api/share/{}", share_id.0))
                 .bearer_auth(session.access_token)
                 .send()
                 .await
-                .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
+                .map_err(|err| err::ResponseError::InternalServerError (err))?;
             match resp.json::<Value>().await {
                 Ok(mut share_data) => {
                     if let Some(replace) = share_data
@@ -623,7 +702,7 @@ async fn get_share_chat_continue_info(
                                 "public": {}
                             },
                             "isUserInCanPayGroup": true,
-                            "sharedConversationId": share_id.into_inner(),
+                            "sharedConversationId": share_id.0,
                             "serverResponse": {
                                 "type": "data",
                                 "data": share_data,
@@ -651,35 +730,51 @@ async fn get_share_chat_continue_info(
                         },
                         "__N_SSP": true
                     });
-                    Ok(HttpResponse::Ok().json(props))
-                }
-                Err(_) => Ok(HttpResponse::Ok()
-                    .append_header(("referrer-policy", "same-origin"))
-                    .json(serde_json::json!({"notFound": true}))),
+                    Ok(Response::builder()
+                    .status(StatusCode::OK)
+                    .header(header::CONTENT_TYPE, "applications/json")
+                    .body(Body::from(serde_json::to_string(&props).unwrap()))
+                    .map_err(|err| err::ResponseError::InternalServerError(err))?)
+                }
+                Err(_) => Ok(Response::builder()
+                    .status(StatusCode::OK)
+                    .header(header::CONTENT_TYPE, "same-origin")
+                    .body(Body::from(serde_json::to_string(&serde_json::json!({"notFound": true})).unwrap()))
+                    .map_err(|err| err::ResponseError::InternalServerError(err))?),
             }
             },
             Err(_) => {
-                Ok(HttpResponse::TemporaryRedirect()
-                .json(serde_json::json!({
+                Ok(Response::builder()
+                    .status(StatusCode::TEMPORARY_REDIRECT)
+                            .header(header::CONTENT_TYPE, "applications/json")
+                                .body(Body::from(serde_json::to_string(&serde_json::json!({
                                     "pageProps": {
-                        "__N_REDIRECT": format!("/auth/login?next=%2Fshare%2F{}%2Fcontinue", share_id.into_inner()),
+                                        "__N_REDIRECT": format!("/auth/login?next=%2Fshare%2F{}%2Fcontinue", share_id.0),
                                         "__N_REDIRECT_STATUS": 307
                                     },
                                     "__N_SSP": true
-                })))
+                                })).unwrap())).map_err(|err| err::ResponseError::InternalServerError(err))?)
             },
         };
     }
-    redirect_login()
+    // redirect_login()
+    todo!()
 }
 
-async fn get_image(params: Option<web::Query<ImageQuery>>) -> Result<HttpResponse> {
-    let query = params.ok_or(error::ErrorBadRequest("Missing URL parameter"))?;
+async fn get_image(
+    params: Option<axum::extract::Query<ImageQuery>>,
+) -> Result<
+    Response<StreamBody<impl futures_core::Stream<Item = Result<bytes::Bytes, reqwest::Error>>>>,
+    ResponseError,
+> {
+    let query = params.ok_or(err::ResponseError::BadRequest(anyhow::anyhow!(
+        "Missing URL parameter"
+    )))?;
     let resp = super::api_client().get(&query.url).send().await;
-    Ok(super::response_convert(resp))
+    super::response_convert(resp)
 }
 
-async fn get_error_404() -> Result<HttpResponse> {
+async fn error_404() -> Result<Response<Body>, ResponseError> {
     let mut ctx = tera::Context::new();
     let props = json!(
         {
@@ -698,37 +793,42 @@ async fn get_error_404() -> Result<HttpResponse> {
     ctx.insert(
         "props",
         &serde_json::to_string(&props)
-            .map_err(|e| error::ErrorInternalServerError(e.to_string()))?,
+            .map_err(|err| err::ResponseError::InternalServerError(err))?,
     );
     render_template(TEMP_404, &ctx)
 }
 
-fn extract_session(cookie_value: &str) -> Result<Session> {
+fn extract_session(cookie_value: &str) -> Result<Session, ResponseError> {
     Session::try_from(cookie_value)
-        .map_err(|_| error::ErrorUnauthorized("invalid session"))
+        .map_err(|_| err::ResponseError::Unauthorized(anyhow!("invalid session")))
         .and_then(|session| match check_token(&session.access_token) {
             Ok(_) => Ok(session),
             Err(err) => Err(err),
         })
 }
 
-fn redirect_login() -> Result<HttpResponse> {
-    Ok(HttpResponse::Found()
-        .insert_header((header::LOCATION, "/auth/login"))
-        .finish())
+fn redirect_login() -> Result<Response<Body>, ResponseError> {
+    Ok(Response::builder()
+        .status(StatusCode::FOUND)
+        .header(header::LOCATION, LOGIN_INDEX)
+        .body(Body::empty())
+        .map_err(|err| err::ResponseError::InternalServerError(err))?)
 }
 
-fn render_template(name: &str, context: &tera::Context) -> Result<HttpResponse> {
+fn render_template(name: &str, context: &tera::Context) -> Result<Response<Body>, ResponseError> {
     let tm = unsafe {
         TEMPLATE
             .as_ref()
             .unwrap()
             .render(name, context)
-            .map_err(|e| error::ErrorInternalServerError(e.to_string()))
+            .map_err(|err| err::ResponseError::InternalServerError(err))
     }?;
-    Ok(HttpResponse::Ok()
-        .content_type(header::ContentType::html())
-        .body(tm))
+
+    Ok(Response::builder()
+        .status(StatusCode::OK)
+        .header(header::CONTENT_TYPE, "text/html; charset=utf-8")
+        .body(Body::from(tm))
+        .map_err(|err| err::ResponseError::InternalServerError(err))?)
 }
 
 fn settings_template_data(ctx: &mut tera::Context) {
@@ -741,25 +841,26 @@ fn settings_template_data(ctx: &mut tera::Context) {
     }
 }
 
-fn check_token(token: &str) -> Result<()> {
-    let _ = crate::token::check(token).map_err(|e| error::ErrorUnauthorized(e.to_string()))?;
+fn check_token(token: &str) -> Result<(), ResponseError> {
+    let _ = crate::token::check(token).map_err(|err| err::ResponseError::Unauthorized(err))?;
     Ok(())
 }
 
-async fn cf_captcha_check(req: &HttpRequest, cf_response: Option<&str>) -> Result<()> {
+async fn cf_captcha_check(addr: IpAddr, cf_response: Option<&str>) -> Result<(), ResponseError> {
     let data = unsafe { TEMPLATE_DATA.as_ref().unwrap() };
     if data.cf_site_key.is_some() && data.cf_secret_key.is_some() {
         return match cf_response {
             Some(cf_response) => {
                 if cf_response.is_empty() {
-                    return Err(error::ErrorBadRequest("Missing cf_captcha_response"));
+                    return Err(err::ResponseError::BadRequest(anyhow::anyhow!(
+                        "Missing cf_captcha_response"
+                    )));
                 }
 
-                let conn = req.connection_info();
                 let form = CfCaptchaForm {
                     secret: data.cf_secret_key.as_ref().unwrap(),
                     response: cf_response,
-                    remoteip: conn.peer_addr().unwrap(),
+                    remoteip: &addr.to_string(),
                     idempotency_key: crate::uuid::uuid(),
                 };
 
@@ -768,24 +869,33 @@ async fn cf_captcha_check(req: &HttpRequest, cf_response: Option<&str>) -> Resul
                     .form(&form)
                     .send()
                     .await
-                    .map_err(|e| error::ErrorInternalServerError(e.to_string()))?;
+                    .map_err(|err| err::ResponseError::InternalServerError(err))?;
                 match resp.error_for_status() {
                     Ok(_) => Ok(()),
-                    Err(e) => Err(error::ErrorUnauthorized(e.to_string())),
+                    Err(err) => Err(err::ResponseError::Unauthorized(err)),
                 }
             }
-            None => Err(error::ErrorBadRequest("Missing cf_captcha_response")),
+            None => Err(err::ResponseError::BadRequest(anyhow::anyhow!(
+                "Missing cf_captcha_response"
+            ))),
         };
     };
     Ok(())
 }
 
-async fn get_static_resource(path: web::Path<String>) -> impl Responder {
-    let path = path.into_inner();
+async fn get_static_resource(path: Path<String>) -> Result<Response<Body>, ResponseError> {
+    let path = path.0;
     let mut x = unsafe { STATIC_FILES.as_ref().unwrap().iter() };
     match x.find(|(k, _v)| k.contains(&path)) {
-        Some((_, v)) => HttpResponse::Ok().content_type(v.mime_type).body(v.data),
-        None => HttpResponse::NotFound().finish(),
+        Some((_, v)) => Ok(Response::builder()
+            .status(StatusCode::OK)
+            .header(header::CONTENT_TYPE, v.mime_type)
+            .body(Body::from(v.data))
+            .map_err(|err| err::ResponseError::InternalServerError(err))?),
+        None => Ok(Response::builder()
+            .status(StatusCode::NOT_FOUND)
+            .body(Body::empty())
+            .map_err(|err| err::ResponseError::InternalServerError(err))?),
     }
 }
 
