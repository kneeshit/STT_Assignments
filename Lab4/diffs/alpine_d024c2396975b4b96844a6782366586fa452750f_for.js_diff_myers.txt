diff --git a/src/directives/for.js b/src/directives/for.js
index f456e412..51b2892a 100644
--- a/src/directives/for.js
+++ b/src/directives/for.js
@@ -1,143 +1,137 @@
 import { transitionIn, transitionOut, getXAttrs } from '../utils'
 
-export function handleForDirective(component, el, expression, initialUpdate, extraVars) {
-    if (el.tagName.toLowerCase() !== 'template') console.warn('Alpine: [x-for] directive should only be added to <template> tags.')
+export function handleForDirective(component, templateEl, expression, initialUpdate, extraVars) {
+    warnIfNotTemplateTag(templateEl)
+
+    let iteratorNames = parseForExpression(expression)
+
+    let items = evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, templateEl, iteratorNames, extraVars)
+
+    // As we walk the array, we'll also walk the DOM (updating/creating as we go).
+    let currentEl = templateEl
+    items.forEach((item, index) => {
+        let iterationScopeVariables = getIterationScopeVariables(iteratorNames, item, index, items)
+        let currentKey = generateKeyForIteration(component, templateEl, index, iterationScopeVariables)
+        let nextEl = currentEl.nextElementSibling
+
+        // If there's no previously x-for processed element ahead, add one.
+        if (! nextEl || nextEl.__x_for_key === undefined) {
+            nextEl = addElementInLoopAfterCurrentEl(templateEl, currentEl)
 
-    const { single, bunch, iterator1, iterator2 } = parseFor(expression)
+            // And transition it in if it's not the first page load.
+            transitionIn(nextEl, () => {}, initialUpdate)
 
-    var items
-    const ifAttr = getXAttrs(el, 'if')[0]
-    if (ifAttr && ! component.evaluateReturnExpression(el, ifAttr.expression))  {
-        // If there is an "x-if" attribute in conjunction with an x-for,
-        // AND x-if resolves to false, just pretend the x-for is
-        // empty, effectively hiding it.
-        items = []
+            nextEl.__x_for = iterationScopeVariables
+            component.initializeElements(nextEl, () => nextEl.__x_for)
         } else {
-        items = component.evaluateReturnExpression(el, bunch, extraVars)
+            nextEl = lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey)
+
+            // Temporarily remove the key indicator to allow the normal "updateElements" to work
+            delete nextEl.__x_for_key
+
+            nextEl.__x_for = iterationScopeVariables
+            component.updateElements(nextEl, () => nextEl.__x_for)
         }
 
-    // As we walk the array, we'll also walk the DOM (updating/creating as we go).
-    var previousEl = el
-    items.forEach((i, index, group) => {
-        const currentKey = getThisIterationsKeyFromTemplateTag(component, el, single, iterator1, iterator2, i, index, group)
-        let currentEl = previousEl.nextElementSibling
+        currentEl = nextEl
+        currentEl.__x_for_key = currentKey
+    })
 
-        // Let's check and see if the x-for has already generated an element last time it ran.
-        if (currentEl && currentEl.__x_for_key !== undefined) {
-            // If the the key's don't match.
-            if (currentEl.__x_for_key !== currentKey) {
-                // We'll look ahead to see if we can find it further down.
-                var tmpCurrentEl = currentEl
-                while(tmpCurrentEl) {
-                    // If we found it later in the DOM.
-                    if (tmpCurrentEl.__x_for_key === currentKey) {
-                        // Move it to where it's supposed to be in the DOM.
-                        el.parentElement.insertBefore(tmpCurrentEl, currentEl)
-                        // And set it as the current element as if we just created it.
-                        currentEl = tmpCurrentEl
-                        break
+    removeAnyLeftOverElementsFromPreviousUpdate(currentEl)
 }
 
-                    tmpCurrentEl = (tmpCurrentEl.nextElementSibling && tmpCurrentEl.nextElementSibling.__x_for_key !== undefined) ? tmpCurrentEl.nextElementSibling : false
+// This was taken from VueJS 2.* core. Thanks Vue!
+function parseForExpression(expression) {
+    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
+    let stripParensRE = /^\(|\)$/g
+    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/
+    let inMatch = expression.match(forAliasRE)
+    if (! inMatch) return
+    let res = {}
+    res.items = inMatch[2].trim()
+    let item = inMatch[1].trim().replace(stripParensRE, '')
+    let iteratorMatch = item.match(forIteratorRE)
+
+    if (iteratorMatch) {
+        res.item = item.replace(forIteratorRE, '').trim()
+        res.index = iteratorMatch[1].trim()
+
+        if (iteratorMatch[2]) {
+            res.collection = iteratorMatch[2].trim()
         }
+    } else {
+        res.item = item
+    }
+    return res
 }
 
-            // Temporarily remove the key indicator to allow the normal "updateElements" to work
-            delete currentEl.__x_for_key
-
-            let xForVars = {}
-            xForVars[single] = i
-            if (iterator1) xForVars[iterator1] = index
-            if (iterator2) xForVars[iterator2] = group
-            currentEl.__x_for = xForVars
-            component.updateElements(currentEl, () => {
-                return currentEl.__x_for
-            })
-        } else {
-            // There are no more .__x_for_key elements, meaning the page is first loading, OR, there are
-            // extra items in the array that need to be added as new elements.
+function getIterationScopeVariables(iteratorNames, item, index, items) {
+    let scopeVariables = { [iteratorNames.item]: item }
+    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index
+    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items
 
-            // Let's create a clone from the template.
-            const clone = document.importNode(el.content, true)
+    return scopeVariables
+}
 
-            if (clone.childElementCount !== 1) console.warn('Alpine: <template> tag with [x-for] encountered with multiple element roots. Make sure <template> only has a single child node.')
+function generateKeyForIteration(component, el, index, iterationScopeVariables) {
+    let bindKeyAttribute = getXAttrs(el, 'bind').filter(attr => attr.value === 'key')[0]
 
-            // Insert it where we are in the DOM.
-            el.parentElement.insertBefore(clone, currentEl)
+    // If the dev hasn't specified a key, just return the index of the iteration.
+    if (! bindKeyAttribute) return index
 
-            // Set it as the current element.
-            currentEl = previousEl.nextElementSibling
+    return component.evaluateReturnExpression(el, bindKeyAttribute.expression, () => iterationScopeVariables)
+}
 
-            // And transition it in if it's not the first page load.
-            transitionIn(currentEl, () => {}, initialUpdate)
-
-            // Now, let's walk the new DOM node and initialize everything,
-            // including new nested components.
-            // Note we are resolving the "extraData" alias stuff from the dom element value so that it's
-            // always up to date for listener handlers that don't get re-registered.
-            let xForVars = {}
-            xForVars[single] = i
-            if (iterator1) xForVars[iterator1] = index
-            if (iterator2) xForVars[iterator2] = group
-            currentEl.__x_for = xForVars
-            component.initializeElements(currentEl, () => {
-                return currentEl.__x_for
-            })
+function warnIfNotTemplateTag(el) {
+    if (el.tagName.toLowerCase() !== 'template') console.warn('Alpine: [x-for] directive should only be added to <template> tags.')
 }
 
-        currentEl.__x_for_key = currentKey
+function evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, el, iteratorNames, extraVars) {
+    let ifAttribute = getXAttrs(el, 'if')[0]
 
-        previousEl = currentEl
-    })
+    if (ifAttribute && ! component.evaluateReturnExpression(el, ifAttribute.expression)) {
+        return []
+    }
 
-    // Now that we've added/updated/moved all the elements for the current state of the loop.
-    // Anything left over, we can get rid of.
-    var nextElementFromOldLoop = (previousEl.nextElementSibling && previousEl.nextElementSibling.__x_for_key !== undefined) ? previousEl.nextElementSibling : false
+    return component.evaluateReturnExpression(el, iteratorNames.items, extraVars)
+}
 
-    while(nextElementFromOldLoop) {
-        const nextElementFromOldLoopImmutable = nextElementFromOldLoop
-        const nextSibling = nextElementFromOldLoop.nextElementSibling
+function addElementInLoopAfterCurrentEl(templateEl, currentEl) {
+    let clone = document.importNode(templateEl.content, true  )
 
-        transitionOut(nextElementFromOldLoop, () => {
-            nextElementFromOldLoopImmutable.remove()
-        })
+    if (clone.childElementCount !== 1) console.warn('Alpine: <template> tag with [x-for] encountered with multiple element roots. Make sure <template> only has a single child node.')
 
-        nextElementFromOldLoop = (nextSibling && nextSibling.__x_for_key !== undefined) ? nextSibling : false
-    }
+    currentEl.parentElement.insertBefore(clone, currentEl.nextElementSibling)
+
+    return currentEl.nextElementSibling
 }
 
-// This was taken from VueJS 2.* core. Thanks Vue!
-function parseFor (expression) {
-    const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
-    const stripParensRE = /^\(|\)$/g
-    const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/
+function lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey) {
+    // If the the key's DO match, no need to look ahead.
+    if (nextEl.__x_for_key === currentKey) return nextEl
 
-    const inMatch = expression.match(forAliasRE)
-    if (! inMatch) return
-    const res = {}
-    res.bunch = inMatch[2].trim()
-    const single = inMatch[1].trim().replace(stripParensRE, '')
-    const iteratorMatch = single.match(forIteratorRE)
-    if (iteratorMatch) {
-        res.single = single.replace(forIteratorRE, '').trim()
-        res.iterator1 = iteratorMatch[1].trim()
-        if (iteratorMatch[2]) {
-            res.iterator2 = iteratorMatch[2].trim()
+    // If the don't, we'll look ahead for a match.
+    // If we find it, we'll move it to the current position in the loop.
+    let tmpNextEl = nextEl
+
+    while(tmpNextEl) {
+        if (tmpNextEl.__x_for_key === currentKey) {
+            return tmpNextEl.parentElement.insertBefore(tmpNextEl, nextEl)
         }
-    } else {
-        res.single = single
+
+        tmpNextEl = (tmpNextEl.nextElementSibling && tmpNextEl.nextElementSibling.__x_for_key !== undefined) ? tmpNextEl.nextElementSibling : false
     }
-    return res
 }
 
-function getThisIterationsKeyFromTemplateTag(component, el, single, iterator1, iterator2, i, index, group) {
-    const keyAttr = getXAttrs(el, 'bind').filter(attr => attr.value === 'key')[0]
+function removeAnyLeftOverElementsFromPreviousUpdate(currentEl) {
+    var nextElementFromOldLoop = (currentEl.nextElementSibling && currentEl.nextElementSibling.__x_for_key !== undefined) ? currentEl.nextElementSibling : false
 
-    let keyAliases = { [single]: i }
-    if (iterator1) keyAliases[iterator1] = index
-    if (iterator2) keyAliases[iterator2] = group
-
-    return keyAttr
-        ? component.evaluateReturnExpression(el, keyAttr.expression, () => keyAliases)
-        : index
+    while (nextElementFromOldLoop) {
+        let nextElementFromOldLoopImmutable = nextElementFromOldLoop
+        let nextSibling = nextElementFromOldLoop.nextElementSibling
+        transitionOut(nextElementFromOldLoop, () => {
+            nextElementFromOldLoopImmutable.remove()
+        })
+        nextElementFromOldLoop = (nextSibling && nextSibling.__x_for_key !== undefined) ? nextSibling : false
+    }
 }
