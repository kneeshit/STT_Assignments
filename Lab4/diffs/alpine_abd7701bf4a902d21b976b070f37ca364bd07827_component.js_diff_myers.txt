diff --git a/src/component.js b/src/component.js
index 70754dac..e9e10a41 100644
--- a/src/component.js
+++ b/src/component.js
@@ -1,25 +1,50 @@
-import { walk, onlyUnique, saferEval, hasXAttr, getXAttrs } from './utils'
+import { walk, onlyUnique, saferEval, saferEvalNoReturn, getXAttrs, debounce } from './utils'
 
 export default class Component {
     constructor(el) {
         this.el = el
 
-        this.data = saferEval(this.el.getAttribute('x-data'))
+        this.data = saferEval(this.el.getAttribute('x-data'), {})
+
+        this.concernedData = []
 
         this.registerListeners()
 
-        this.updateBoundAttributes(() => { return true })
+        this.updateAllBoundAttributes()
     }
 
     registerListeners() {
-        // Do a sweep through the component, find out what events children are
-        // listening for so we can do "event delegation" on the root.
-        // The reason for using event delegation is so that new
-        // DOM element listeners can potentially be added
-        // and they will be detected.
-        this.eventsThisComponentIsListeningFor().forEach(eventName => {
-            this.el.addEventListener(eventName, e => {
-                if (e.target.hasAttribute(`x-on:${eventName}`)) {
+        walk(this.el, el => {
+            getXAttrs(el, 'on').forEach(({ type, value, modifiers, expression }) => {
+                if (modifiers.includes('away')) {
+                    // Listen for this event at the root level.
+                    document.addEventListener(value, e => {
+                        // Don't do anything if the click came form the element or within it.
+                        if (el.contains(e.target)) return
+
+                        // Don't do anything if this element isn't currently visible.
+                        if (el.offsetWidth < 1 && el.offsetHeight < 1) return
+
+                        // Now that we are sure the element is visible, AND the click
+                        // is from outside it, let's run the expression.
+                        this.concernedData.push(...this.evaluateExpressionWithEvent(expression, e))
+                        this.concernedData = this.concernedData.filter(onlyUnique)
+
+                        this.updateBoundAttributes()
+                    })
+                } else {
+                    el.addEventListener(value, e => {
+                        this.concernedData.push(...this.evaluateExpressionWithEvent(expression, e))
+                        this.concernedData = this.concernedData.filter(onlyUnique)
+
+                        this.updateBoundAttributes()
+                    })
+                }
+            })
+        })
+    }
+
+    evaluateExpressionWithEvent(expression, event) {
         var mutatedDataItems = []
 
         // Detect if the listener action mutated some data,
@@ -34,23 +59,14 @@ export default class Component {
             }
         })
 
-                    const expression = e.target.getAttribute(`x-on:${eventName}`)
-
-                    saferEval(expression, {
-                        '$data': proxiedData,
-                        '$event': e,
+        saferEvalNoReturn(expression, proxiedData, {
+            '$event': event,
         })
 
-                    this.updateBoundAttributes(isConscernedWith => {
-                        return mutatedDataItems.filter(i => isConscernedWith.includes(i)).length > 0;
-                    })
-                }
-            })
-        })
+        return mutatedDataItems;
     }
 
-    eventsThisComponentIsListeningFor()
-    {
+    eventsThisComponentIsListeningFor() {
         var eventsToListenFor = []
 
         walk(this.el, el => {
@@ -65,15 +81,13 @@ export default class Component {
         return eventsToListenFor.filter(onlyUnique)
     }
 
-    updateBoundAttributes(ifConcernedWith) {
-        walk(this.el, el => {
-            if (hasXAttr(el, 'bind')) {
-                getXAttrs(el, 'bind').forEach(attr => {
-                    const boundAttribute = attr.name.replace(/x-bind:/, '')
-                    const expression = attr.value
+    updateBoundAttributes() {
+        var self = this
+        debounce(walk, 5)(this.el, function (el) {
+            getXAttrs(el, 'bind').forEach(({ type, value, modifiers, expression }) => {
                 var isConscernedWith = []
 
-                    const proxiedData = new Proxy(this.data, {
+                const proxiedData = new Proxy(self.data, {
                     get(object, prop) {
                         isConscernedWith.push(prop)
 
@@ -81,14 +95,33 @@ export default class Component {
                     }
                 })
 
-                    const result = saferEval(expression, {"$data":  proxiedData})
+                const result = saferEval(expression, proxiedData)
 
-                    if (ifConcernedWith(isConscernedWith)) {
-                        this.updateBoundAttributeValue(el, boundAttribute, result)
+                if (self.concernedData.filter(i => isConscernedWith.includes(i)).length > 0) {
+                    self.updateBoundAttributeValue(el, value, result)
                 }
             })
+        })
+    }
+
+    updateAllBoundAttributes() {
+            walk(this.el, el => {
+                getXAttrs(el, 'bind').forEach(({ type, value, modifiers, expression }) => {
+                    var isConscernedWith = []
+
+                    const proxiedData = new Proxy(this.data, {
+                        get(object, prop) {
+                            isConscernedWith.push(prop)
+
+                            return object[prop]
                         }
                     })
+
+                    const result = saferEval(expression, proxiedData)
+
+                    this.updateBoundAttributeValue(el, value, result)
+                })
+            })
     }
 
     updateBoundAttributeValue(el, attrName, value) {
