diff --git a/openai/src/serve/router/ui.rs b/openai/src/serve/router/ui.rs
index 3d67951..749f1c7 100644
--- a/openai/src/serve/router/ui.rs
+++ b/openai/src/serve/router/ui.rs
@@ -1,8 +1,3 @@
-use std::collections::HashMap;
-use std::net::SocketAddr;
-use std::str::FromStr;
-use std::sync::OnceLock;
-
 use anyhow::anyhow;
 use axum::body::Body;
 use axum::extract::ConnectInfo;
@@ -19,6 +14,10 @@ use axum::Router;
 use axum::TypedHeader;
 use axum_extra::extract::cookie;
 use axum_extra::extract::CookieJar;
+use std::collections::HashMap;
+use std::net::SocketAddr;
+use std::str::FromStr;
+use std::sync::OnceLock;
 
 use base64::Engine;
 
@@ -27,6 +26,8 @@ use serde::{Deserialize, Serialize};
 use serde_json::{json, Value};
 use time::format_description::well_known::Rfc3339;
 
+use crate::auth::model::AccessToken;
+use crate::auth::API_AUTH_SESSION_COOKIE_KEY;
 use crate::context;
 use crate::context::ContextArgs;
 use crate::debug;
@@ -61,11 +62,12 @@ static TEMPLATE: OnceLock<tera::Tera> = OnceLock::new();
 
 #[derive(Serialize, Deserialize)]
 struct Session {
-    refresh_token: Option<String>,
     access_token: String,
+    refresh_token: Option<String>,
+    #[serde(skip_serializing)]
+    auth_session: Option<String>,
     user_id: String,
     email: String,
-    expires_in: i64,
     expires: i64,
 }
 
@@ -73,7 +75,7 @@ impl ToString for Session {
     fn to_string(&self) -> String {
         let json = serde_json::to_string(self)
             .expect("An error occurred during the internal serialization session");
-        base64::engine::general_purpose::URL_SAFE.encode(json.as_bytes())
+        base64::engine::general_purpose::STANDARD.encode(json.as_bytes())
     }
 }
 
@@ -81,7 +83,7 @@ impl FromStr for Session {
     type Err = ResponseError;
 
     fn from_str(s: &str) -> Result<Self, Self::Err> {
-        let data = base64::engine::general_purpose::URL_SAFE
+        let data = base64::engine::general_purpose::STANDARD
             .decode(s)
             .map_err(ResponseError::Unauthorized)?;
         serde_json::from_slice(&data).map_err(ResponseError::Unauthorized)
@@ -94,9 +96,9 @@ impl From<AuthenticateToken> for Session {
             user_id: value.user_id().to_owned(),
             email: value.email().to_owned(),
             access_token: value.access_token().to_owned(),
-            expires_in: value.expires_in(),
             expires: value.expires(),
             refresh_token: value.refresh_token().map(|v| v.to_owned()),
+            auth_session: value.auth_session().map(|v| v.to_owned()),
         }
     }
 }
@@ -219,14 +221,28 @@ async fn post_login(
             let cookie = cookie::Cookie::build(SESSION_ID, session.to_string())
                 .path(DEFAULT_INDEX)
                 .same_site(cookie::SameSite::Lax)
-                .max_age(time::Duration::seconds(session.expires_in))
+                .expires(time::OffsetDateTime::from_unix_timestamp(session.expires)?)
                 .secure(false)
                 .http_only(false)
                 .finish();
 
-            Ok(Response::builder()
+            let mut builder = Response::builder()
                 .status(StatusCode::SEE_OTHER)
-                .header(header::LOCATION, DEFAULT_INDEX)
+                .header(header::LOCATION, DEFAULT_INDEX);
+
+            if let Some(value) = session.auth_session {
+                let auth_cookie = cookie::Cookie::build(API_AUTH_SESSION_COOKIE_KEY, value)
+                    .path(DEFAULT_INDEX)
+                    .same_site(cookie::SameSite::Lax)
+                    .expires(time::OffsetDateTime::from_unix_timestamp(session.expires)?)
+                    .secure(true)
+                    .http_only(false)
+                    .finish();
+
+                builder = builder.header(header::SET_COOKIE, auth_cookie.to_string())
+            }
+
+            Ok(builder
                 .header(header::SET_COOKIE, cookie.to_string())
                 .body(Body::empty())
                 .map_err(ResponseError::InternalServerError)?)
@@ -256,18 +272,18 @@ async fn post_login_token(
         )))?;
 
     let session = Session {
-        refresh_token: None,
         access_token: access_token.to_owned(),
         user_id: profile.user_id().to_owned(),
         email: profile.email().to_owned(),
-        expires_in: profile.expires_in(),
         expires: profile.expires(),
+        refresh_token: None,
+        auth_session: None,
     };
 
     let cookie = cookie::Cookie::build(SESSION_ID, session.to_string())
         .path(DEFAULT_INDEX)
         .same_site(cookie::SameSite::Lax)
-        .max_age(time::Duration::seconds(session.expires_in))
+        .expires(time::OffsetDateTime::from_unix_timestamp(session.expires)?)
         .secure(false)
         .http_only(false)
         .finish();
@@ -318,17 +334,65 @@ async fn get_logout(jar: CookieJar) -> Result<Response<Body>, ResponseError> {
 }
 
 async fn get_session(jar: CookieJar) -> Result<Response<Body>, ResponseError> {
-    if let Some(cookie) = jar.get(SESSION_ID) {
-        // Extract session from cookie
-        let session = extract_session(cookie.value())?;
+    let session = match jar.get(SESSION_ID) {
+        Some(cookie) => extract_session(cookie.value())?,
+        None => return redirect_login(),
+    };
 
     let current_timestamp = now_duration()?.as_secs() as i64;
-
     if session.expires < current_timestamp {
         return redirect_login();
     }
 
-        fn to_body(session: Session) -> anyhow::Result<String> {
+    if session.expires - current_timestamp <= 21600 {
+        let ctx = context::get_instance();
+        let new_session = if let Some(c) = jar.get(API_AUTH_SESSION_COOKIE_KEY) {
+            match ctx.auth_client().do_session(c.value()).await {
+                Ok(session_token) => {
+                    let authentication_token =
+                        AuthenticateToken::try_from(AccessToken::Session(session_token))?;
+                    Some(Session::from(authentication_token))
+                }
+                Err(err) => {
+                    debug!("Get session token error: {}", err);
+                    None
+                }
+            }
+        } else if let Some(refresh_token) = session.refresh_token.as_ref() {
+            match ctx.auth_client().do_refresh_token(&refresh_token).await {
+                Ok(new_refresh_token) => {
+                    let authentication_token = AuthenticateToken::try_from(new_refresh_token)?;
+                    Some(Session::from(authentication_token))
+                }
+                Err(err) => {
+                    debug!("Refresh token error: {}", err);
+                    None
+                }
+            }
+        } else {
+            None
+        };
+
+        if let Some(new_session) = new_session {
+            return create_response_from_session(&new_session);
+        }
+    }
+
+    create_response_from_session(&session)
+}
+
+fn create_response_from_session(session: &Session) -> Result<Response<Body>, ResponseError> {
+    let body = session_to_body(session)?;
+    Ok(Response::builder()
+        .status(StatusCode::OK)
+        .header(header::LOCATION, LOGIN_INDEX)
+        .header(header::SET_COOKIE, session.to_string()) // Note: This might not be what you want
+        .header(header::CONTENT_TYPE, "application/json")
+        .body(Body::from(body))
+        .map_err(ResponseError::InternalServerError)?)
+}
+
+fn session_to_body(session: &Session) -> anyhow::Result<String> {
     let expires = time::OffsetDateTime::from_unix_timestamp(session.expires)
         .map(|v| v.format(&Rfc3339))??;
     let props = serde_json::json!({
@@ -347,45 +411,6 @@ async fn get_session(jar: CookieJar) -> Result<Response<Body>, ResponseError> {
     Ok(props.to_string())
 }
 
-        fn to_response(
-            session: Session,
-            cookie: &cookie::Cookie,
-        ) -> Result<Response<Body>, ResponseError> {
-            Ok(Response::builder()
-                .status(StatusCode::OK)
-                .header(header::LOCATION, LOGIN_INDEX)
-                .header(header::SET_COOKIE, cookie.to_string())
-                .header(header::CONTENT_TYPE, "application/json")
-                .body(Body::from(to_body(session)?))
-                .map_err(ResponseError::InternalServerError)?)
-        }
-
-        if let Some(refresh_token) = session.refresh_token.as_ref() {
-            if session.expires - current_timestamp <= (session.expires_in / 5) {
-                let ctx = context::get_instance();
-                match ctx.auth_client().do_refresh_token(&refresh_token).await {
-                    Ok(refresh_token) => {
-                        let authentication_token = AuthenticateToken::try_from(refresh_token)?;
-                        let session = Session::from(authentication_token);
-                        let cookie = cookie::Cookie::build(SESSION_ID, session.to_string())
-                            .path(DEFAULT_INDEX)
-                            .same_site(cookie::SameSite::Lax)
-                            .max_age(time::Duration::seconds(session.expires_in))
-                            .secure(false)
-                            .http_only(false)
-                            .finish();
-                        return to_response(session, &cookie);
-                    }
-                    Err(err) => debug!("Refresh token error: {}", err),
-                }
-            }
-        }
-
-        return to_response(session, cookie);
-    }
-    redirect_login()
-}
-
 async fn get_chat(
     jar: CookieJar,
     conversation_id: Option<Path<String>>,
