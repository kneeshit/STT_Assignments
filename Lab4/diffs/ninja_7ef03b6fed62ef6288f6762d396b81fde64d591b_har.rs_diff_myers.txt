diff --git a/openai/src/serve/router/har.rs b/openai/src/serve/router/har.rs
index 825a766..af0e0d8 100644
--- a/openai/src/serve/router/har.rs
+++ b/openai/src/serve/router/har.rs
@@ -1,4 +1,6 @@
-use crate::context::Context;
+use std::str::FromStr;
+
+use crate::context;
 use crate::serve::{err::ResponseError, Launcher};
 use crate::{arkose, debug};
 use anyhow::anyhow;
@@ -24,7 +26,7 @@ pub(super) fn config(router: Router, _: &Launcher) -> Router {
 }
 
 async fn upload() -> Html<String> {
-    let ctx = Context::get_instance().await;
+    let ctx = context::get_instance();
     let tm = UPLOAD_PAGE.replace(
         "{{.key}}",
         &ctx.arkose_har_upload_key().is_some().to_string(),
@@ -34,10 +36,10 @@ async fn upload() -> Html<String> {
 
 async fn upload_form(
     bearer: Option<TypedHeader<Authorization<Bearer>>>,
+    _type: TypedHeader<PlatformType>,
     mut multipart: Multipart,
 ) -> Result<Html<String>, ResponseError> {
-    let ctx = Context::get_instance().await;
-
+    let ctx = context::get_instance();
     if let Some(field) = multipart
         .next_field()
         .await
@@ -59,7 +61,7 @@ async fn upload_form(
         if let Some(key) = ctx.arkose_har_upload_key() {
             match bearer {
                 Some(h) => {
-                    if key != h.token() {
+                    if key.ne(h.token()) {
                         return error_html("Authorization key error");
                     }
                 }
@@ -74,17 +76,13 @@ async fn upload_form(
             );
         }
 
-        match ctx.arkose_har_file() {
-            Some(path) => {
-                if tokio::fs::write(path, data).await.is_err() {
+        if tokio::fs::write(ctx.arkose_har_path(&_type.0 .0).1, data)
+            .await
+            .is_err()
+        {
             return error_html("File write error");
         }
     }
-            None => {
-                return error_html("You have to set the path of the uploaded file");
-            }
-        }
-    }
 
     Ok(Html::from(SUCCESS_PAGE.to_owned()))
 }
@@ -93,3 +91,40 @@ fn error_html(error_message: &str) -> Result<Html<String>, ResponseError> {
     let error = ERROR_PAGE.replace("{{.error}}", error_message);
     Ok(Html::from(error))
 }
+
+use axum::headers::{Header, HeaderName, HeaderValue};
+
+struct PlatformType(arkose::Type);
+
+static TYPE: HeaderName = HeaderName::from_static("type");
+
+impl Header for PlatformType {
+    fn name() -> &'static HeaderName {
+        &TYPE
+    }
+
+    fn decode<'i, I>(values: &mut I) -> Result<Self, axum::headers::Error>
+    where
+        I: Iterator<Item = &'i HeaderValue>,
+    {
+        let value = values.next().ok_or_else(axum::headers::Error::invalid)?;
+        let s = value
+            .to_str()
+            .map_err(|_| axum::headers::Error::invalid())?;
+        let target = arkose::Type::from_str(s).map_err(|_| axum::headers::Error::invalid())?;
+        Ok(PlatformType(target))
+    }
+
+    fn encode<E>(&self, values: &mut E)
+    where
+        E: Extend<HeaderValue>,
+    {
+        let s = match self {
+            PlatformType(arkose::Type::Chat) => "chat",
+            PlatformType(arkose::Type::Platform) => "platform",
+            PlatformType(arkose::Type::Auth0) => "auth0",
+        };
+        let value = HeaderValue::from_str(s).expect("invalid header value");
+        values.extend(std::iter::once(value));
+    }
+}
