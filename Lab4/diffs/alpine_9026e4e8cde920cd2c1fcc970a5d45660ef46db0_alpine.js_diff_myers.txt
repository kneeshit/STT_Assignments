diff --git a/dist/alpine.js b/dist/alpine.js
index d2ac1f54..c67dab6f 100644
--- a/dist/alpine.js
+++ b/dist/alpine.js
@@ -389,15 +389,6 @@
       });
     });
   }
-  function getTargetFromPropertiesPath(path, parent, context) {
-    var child = parent[path[0]];
-
-    if (typeof child === 'object' && path.length > 1) {
-      return getTargetFromPropertiesPath(path.slice(1), context.membrane.unwrapProxy(child), context);
-    }
-
-    return typeof child === 'object' ? child : parent;
-  }
 
   function isNumeric(subject) {
     return !isNaN(subject);
@@ -1300,14 +1291,30 @@
       var self = this;
       let membrane = new ReactiveMembrane({
         valueMutated(target, key) {
-          Object.keys(self.watchers).forEach(watcherKey => {
-            const watcherKeyPath = watcherKey.split('.');
-            const watcherTarget = getTargetFromPropertiesPath(watcherKeyPath, self.membrane.unwrapProxy(self.$data), self);
+          if (self.watchers[key]) {
+            // If there's a watcher for this specific key, run it.
+            self.watchers[key].forEach(callback => callback(target[key]));
+          } else {
+            // Let's walk through the watchers with "dot-notation" (foo.bar) and see
+            // if this mutation fits any of them.
+            Object.keys(self.watchers).filter(i => i.includes('.')).forEach(fullDotNotationKey => {
+              let dotNotationParts = fullDotNotationKey.split('.'); // If this dot-notation watcher's last "part" doesn't match the current
+              // key, then skip it early for performance reasons.
 
-            if (target === watcherTarget && key === watcherKeyPath[watcherKeyPath.length - 1]) {
-              self.watchers[watcherKey].forEach(callback => callback(target[key]));
+              if (key !== dotNotationParts[dotNotationParts.length - 1]) return; // Now, walk through the dot-notation "parts" recursively to find
+              // a match, and call the watcher if one's found.
+
+              dotNotationParts.reduce((comparisonData, part) => {
+                if (Object.is(target, comparisonData)) {
+                  // Run the watchers.
+                  self.watchers[fullDotNotationKey].forEach(callback => callback(target[key]));
                 }
-          }); // Don't react to data changes for cases like the `x-created` hook.
+
+                return comparisonData[part];
+              }, self.getUnobservedData());
+            });
+          } // Don't react to data changes for cases like the `x-created` hook.
+
 
           if (self.pauseReactivity) return;
           debounce(() => {
