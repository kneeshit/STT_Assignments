diff --git a/openai/src/auth/provide/mod.rs b/openai/src/auth/provide/mod.rs
index d3dc9e3..fc835bb 100644
--- a/openai/src/auth/provide/mod.rs
+++ b/openai/src/auth/provide/mod.rs
@@ -2,8 +2,16 @@ pub mod apple;
 pub mod platform;
 pub mod web;
 
+use std::collections::HashSet;
+
+use crate::{
+    arkose::{self, ArkoseToken, Type},
+    error::AuthError,
+};
+
 use super::model::{self, AuthStrategy};
 use derive_builder::Builder;
+use reqwest::header;
 use serde::Serialize;
 
 pub type AuthResult<T, E = anyhow::Error> = anyhow::Result<T, E>;
@@ -20,6 +28,105 @@ pub trait AuthProvider: Send + Sync {
     fn supports(&self, t: &AuthStrategy) -> bool;
 }
 
+trait ResponseExt {
+    fn ext_context(self, ctx: &mut AuthContext) -> reqwest::Response;
+}
+
+impl ResponseExt for reqwest::Response {
+    fn ext_context(self, ctx: &mut AuthContext) -> reqwest::Response {
+        ctx.add_cookie(self.cookies());
+        self
+    }
+}
+
+trait RequestBuilderExt {
+    fn ext_cookie(self, ctx: &mut AuthContext) -> reqwest::RequestBuilder;
+}
+
+impl RequestBuilderExt for reqwest::RequestBuilder {
+    fn ext_cookie(self, ctx: &mut AuthContext) -> reqwest::RequestBuilder {
+        self.header(header::COOKIE, ctx.get_cookie())
+    }
+}
+
+struct AuthContext<'a> {
+    account: &'a model::AuthAccount,
+    cookie: HashSet<String>,
+    csrf_token: String,
+    auth_url: String,
+    state: String,
+    code_verifier: String,
+    code_challenge: String,
+}
+
+impl<'a> AuthContext<'a> {
+    pub(super) fn new(account: &'a model::AuthAccount) -> AuthContext<'_> {
+        Self {
+            account,
+            cookie: HashSet::new(),
+            csrf_token: String::new(),
+            auth_url: String::new(),
+            state: String::new(),
+            code_verifier: String::new(),
+            code_challenge: String::new(),
+        }
+    }
+
+    pub(super) fn add_cookie<'b>(
+        &mut self,
+        c: impl Iterator<Item = reqwest::cookie::Cookie<'b>> + 'b,
+    ) {
+        c.for_each(|v| {
+            let _ = self.cookie.insert(format!("{}={}", v.name(), v.value()));
+        });
+    }
+
+    pub(super) fn get_cookie(&self) -> String {
+        self.cookie.iter().cloned().collect::<Vec<_>>().join("; ")
+    }
+
+    pub(super) fn set_csrf_token(&mut self, csrf_token: &str) {
+        self.csrf_token = csrf_token.to_owned();
+    }
+
+    pub(super) fn set_auth_url(&mut self, auth_url: &str) {
+        if self.auth_url.is_empty() {
+            self.auth_url.push_str(auth_url);
+        }
+    }
+
+    pub(super) fn set_state(&mut self, state: &str) {
+        if self.state.is_empty() {
+            self.state.push_str(state);
+        }
+    }
+
+    pub(super) fn set_code_verifier(&mut self, code_verifier: String) {
+        if self.code_verifier.is_empty() {
+            self.code_verifier.push_str(&code_verifier);
+        }
+    }
+
+    pub(super) fn set_code_challenge(&mut self, code_challenge: String) {
+        if self.code_challenge.is_empty() {
+            self.code_challenge.push_str(&code_challenge);
+        }
+    }
+
+    pub(super) async fn load_arkose_token(&mut self) -> AuthResult<()> {
+        let arkose_token = match self.account.arkose_token.as_deref() {
+            Some(arkose_token) => ArkoseToken::from(arkose_token),
+            None => arkose::ArkoseToken::new_from_context(Type::Auth0)
+                .await
+                .map_err(AuthError::InvalidArkoseToken)?,
+        };
+
+        self.cookie
+            .insert(format!("arkoseToken={}", arkose_token.value()));
+        Ok(())
+    }
+}
+
 #[derive(Serialize, Builder)]
 pub(super) struct IdentifierData<'a> {
     state: &'a str,
