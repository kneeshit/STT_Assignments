diff --git a/src/utils.js b/src/utils.js
index 758df713..464aaed1 100644
--- a/src/utils.js
+++ b/src/utils.js
@@ -112,57 +112,226 @@ export function replaceAtAndColonWithStandardSyntax(name) {
     return name
 }
 
-export function transitionIn(el, callback, forceSkip = false) {
-    if (forceSkip) return callback()
+export function transitionIn(el, show, forceSkip = false) {
+    if (forceSkip) return show()
 
     const attrs = getXAttrs(el, 'transition')
+    const showAttr = getXAttrs(el, 'show')[0]
 
-    if (attrs.length < 1) return callback()
+    if (showAttr && showAttr.modifiers.includes('transition')) {
+        let modifiers = showAttr.modifiers
 
-    const enter = (attrs.find(i => i.value === 'enter') || { expression: '' }).expression.split(' ').filter(i => i !== '')
-    const enterStart = (attrs.find(i => i.value === 'enter-start') || { expression: '' }).expression.split(' ').filter(i => i !== '')
-    const enterEnd = (attrs.find(i => i.value === 'enter-end') || { expression: '' }).expression.split(' ').filter(i => i !== '')
+        if (modifiers.includes('out') && ! modifiers.includes('in')) return show()
 
-    transition(el, enter, enterStart, enterEnd, callback, () => {})
+        const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out')
+
+        modifiers = settingBothSidesOfTransition
+            ? modifiers.filter((i, index) => index < modifiers.indexOf('out')) : modifiers
+
+        transitionHelperIn(el, modifiers, show)
+    } else if (attrs.length > 0) {
+        transitionClassesIn(el, attrs, show)
+    } else {
+        show()
+    }
 }
 
-export function transitionOut(el, callback, forceSkip = false) {
-    if (forceSkip) return callback()
+export function transitionOut(el, hide, forceSkip = false) {
+    if (forceSkip) return hide()
 
     const attrs = getXAttrs(el, 'transition')
+    const showAttr = getXAttrs(el, 'show')[0]
 
-    if (attrs.length < 1) return callback()
+    if (showAttr && showAttr.modifiers.includes('transition')) {
+        let modifiers = showAttr.modifiers
 
-    const leave = (attrs.find(i => i.value === 'leave') || { expression: '' }).expression.split(' ').filter(i => i !== '')
-    const leaveStart = (attrs.find(i => i.value === 'leave-start') || { expression: '' }).expression.split(' ').filter(i => i !== '')
-    const leaveEnd = (attrs.find(i => i.value === 'leave-end') || { expression: '' }).expression.split(' ').filter(i => i !== '')
+        if (modifiers.includes('in') && ! modifiers.includes('out')) return hide()
 
-    transition(el, leave, leaveStart, leaveEnd, () => {}, callback)
+        const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out')
+
+        modifiers = settingBothSidesOfTransition
+            ? modifiers.filter((i, index) => index > modifiers.indexOf('out')) : modifiers
+
+        transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hide)
+    } else if (attrs.length > 0) {
+        transitionClassesOut(el, attrs, hide)
+    } else {
+        hide()
+    }
 }
 
-export function transition(el, classesDuring, classesStart, classesEnd, hook1, hook2) {
+export function transitionHelperIn(el, modifiers, showCallback) {
+    // Default values taken from: https://material.io/design/motion/speed.html#duration
+    const styleValues = {
+        duration: modifierValue(modifiers, 'duration', 150),
+        origin: modifierValue(modifiers, 'origin', 'center'),
+        first: {
+            opacity: 0,
+            scale: modifierValue(modifiers, 'scale', 95),
+        },
+        second: {
+            opacity: 1,
+            scale: 100,
+        },
+    }
+
+    transitionHelper(el, modifiers, showCallback, () => {}, styleValues)
+}
+
+export function transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hideCallback) {
+    const duration = settingBothSidesOfTransition
+        ? modifierValue(modifiers, 'duration', 150)
+        : modifierValue(modifiers, 'duration', 150) / 2
+
+    const styleValues = {
+        duration: duration,
+        origin: modifierValue(modifiers, 'origin', 'center'),
+        first: {
+            opacity: 1,
+            scale: 100,
+        },
+        second: {
+            opacity: 0,
+            scale: modifierValue(modifiers, 'scale', 95),
+        },
+    }
+
+    transitionHelper(el, modifiers, () => {}, hideCallback, styleValues)
+}
+
+function modifierValue(modifiers, key, fallback) {
+    if (modifiers.indexOf(key) === -1) return fallback
+
+    const rawValue = modifiers[modifiers.indexOf(key) + 1]
+
+    if (key === 'scale') {
+        // Check if the very next value is NOT a number and return the fallback.
+        if (! isNumeric(rawValue)) return fallback
+    }
+
+    if (! rawValue) return fallback
+
+    if (key === 'duration') {
+        let match = rawValue.match(/([0-9]+)ms/)
+        if (match) return match[1]
+    }
+
+    if (key === 'origin') {
+        if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {
+            return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ')
+        }
+    }
+
+    return rawValue
+}
+
+export function transitionHelper(el, modifiers, hook1, hook2, styleValues) {
+    const opacityCache = el.style.opacity
+    const transformCache = el.style.transform
+    const transformOriginCache = el.style.transformOrigin
+    const noModifiers = ! modifiers.includes('opacity') && ! modifiers.includes('scale')
+    const transitionOpacity = noModifiers || modifiers.includes('opacity')
+    const transitionScale = noModifiers || modifiers.includes('scale')
+
+    const stages = {
+        start() {
+            if (transitionOpacity) el.style.opacity = styleValues.first.opacity
+            if (transitionScale) el.style.transform = `scale(${styleValues.first.scale / 100})`
+        },
+        during() {
+            if (transitionScale) el.style.transformOrigin = styleValues.origin
+            el.style.transitionProperty = [(transitionOpacity ? `opacity` : ``), (transitionScale ? `transform` : ``)].join(' ').trim()
+            el.style.transitionDuration = `${styleValues.duration / 1000}s`
+            el.style.transitionTimingFunction = `cubic-bezier(0.4, 0.0, 0.2, 1)`
+        },
+        show() {
+            hook1()
+        },
+        end() {
+            if (transitionOpacity) el.style.opacity = styleValues.second.opacity
+            if (transitionScale) el.style.transform = `scale(${styleValues.second.scale / 100})`
+        },
+        hide() {
+            hook2()
+        },
+        cleanup() {
+            if (transitionOpacity) el.style.opacity = opacityCache
+            if (transitionScale) el.style.transform = transformCache
+            if (transitionScale) el.style.transformOrigin = transformOriginCache
+            el.style.transitionProperty = null
+            el.style.transitionDuration = null
+            el.style.transitionTimingFunction = null
+        },
+    }
+
+    transition(el, stages)
+}
+
+export function transitionClassesIn(el, directives, showCallback) {
+    const enter = (directives.find(i => i.value === 'enter') || { expression: '' }).expression.split(' ').filter(i => i !== '')
+    const enterStart = (directives.find(i => i.value === 'enter-start') || { expression: '' }).expression.split(' ').filter(i => i !== '')
+    const enterEnd = (directives.find(i => i.value === 'enter-end') || { expression: '' }).expression.split(' ').filter(i => i !== '')
+
+    transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {})
+}
+
+export function transitionClassesOut(el, directives, hideCallback) {
+    const leave = (directives.find(i => i.value === 'leave') || { expression: '' }).expression.split(' ').filter(i => i !== '')
+    const leaveStart = (directives.find(i => i.value === 'leave-start') || { expression: '' }).expression.split(' ').filter(i => i !== '')
+    const leaveEnd = (directives.find(i => i.value === 'leave-end') || { expression: '' }).expression.split(' ').filter(i => i !== '')
+
+    transitionClasses(el, leave, leaveStart, leaveEnd, () => {}, hideCallback)
+}
+
+export function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2) {
     const originalClasses = el.__x_original_classes || []
+
+    const stages = {
+        start() {
             el.classList.add(...classesStart)
+        },
+        during() {
             el.classList.add(...classesDuring)
+        },
+        show() {
+            hook1()
+        },
+        end() {
+            // Don't remove classes that were in the original class attribute.
+            el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)))
+            el.classList.add(...classesEnd)
+        },
+        hide() {
+            hook2()
+        },
+        cleanup() {
+            el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)))
+            el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)))
+        },
+    }
+
+    transition(el, stages)
+}
+
+export function transition(el, stages) {
+    stages.start()
+    stages.during()
 
     requestAnimationFrame(() => {
         const duration = Number(getComputedStyle(el).transitionDuration.replace('s', '')) * 1000
 
-        hook1()
+        stages.show()
 
         requestAnimationFrame(() => {
-            // Don't remove classes that were in the original class attribute.
-            el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)))
-            el.classList.add(...classesEnd)
+            stages.end()
 
             setTimeout(() => {
-                hook2()
+                stages.hide()
 
                 // Adding an "isConnected" check, in case the callback
                 // removed the element from the DOM.
                 if (el.isConnected) {
-                    el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)))
-                    el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)))
+                    stages.cleanup()
                 }
             }, duration);
         })
@@ -191,3 +360,7 @@ export function deepProxy(target, proxyHandler) {
 
     return new Proxy(target, proxyHandler)
 }
+
+function isNumeric(subject){
+    return ! isNaN(subject)
+}
