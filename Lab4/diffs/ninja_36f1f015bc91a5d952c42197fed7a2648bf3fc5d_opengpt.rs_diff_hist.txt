diff --git a/openai/src/api/opengpt.rs b/openai/src/api/opengpt.rs
index e29e946..7284c8c 100644
--- a/openai/src/api/opengpt.rs
+++ b/openai/src/api/opengpt.rs
@@ -1,16 +1,14 @@
 use std::{collections::HashMap, time::Duration};
+use reqwest_impersonate::StatusCode;
 
 use crate::api::ApiError;
 
 use super::{
     models::{req, resp},
-    Api, ApiResult, RefreshToken, StreamResponseWrapper,
+    Api, ApiResult, RefreshToken,
 };
 use async_trait::async_trait;
-use fficall::{
-    model::{RequestMethod, RequestPayloadBuilder, ResponsePayload, StatusCode},
-    StreamLine,
-};
+
 use serde::de::{self, DeserializeOwned};
 use tokio::sync::RwLock;
 use url::Url;
@@ -27,69 +25,8 @@ pub struct OpenGPT {
 }
 
 impl OpenGPT {
-    async fn default_request_builder(
-        &self,
-        url: String,
-        method: RequestMethod,
-    ) -> RequestPayloadBuilder {
-        let mut headers = self.req_headers.clone();
-        headers.insert(
-            reqwest::header::AUTHORIZATION.to_string(),
-            format!("Bearer {}", self.access_token.read().await),
-        );
-        let mut builder = RequestPayloadBuilder::default();
-        if let Some(url) = &self.proxy {
-            builder.proxy_url(url.to_string());
-        }
-        builder
-            .request_url(url)
-            .request_method(method)
-            .timeout_seconds(self.timeout.as_secs() as u32)
-            .without_cookie_jar(self.cookie_store)
-            .headers(headers);
-        builder
-    }
 
-    async fn response_handle<T: DeserializeOwned>(&self, resp: ResponsePayload) -> ApiResult<T> {
-        let status = resp.status();
-        if status.is_success() {
-            Ok(resp
-                .json::<T>()
-                .map_err(ApiError::AnyhowJsonDeserializeError)?)
-        } else {
-            let message = format!("status_code: {:?}, error: {}, ", status, resp.text()?);
-            Err(self.error_handle(status, message).await)
-        }
-    }
 
-    async fn response_stream_handle<T: de::DeserializeOwned>(
-        &self,
-        resp: ResponsePayload,
-    ) -> ApiResult<Box<dyn StreamLine<T>>> {
-        let status = resp.status();
-        if status.is_success() {
-            Ok(Box::new(StreamResponseWrapper(resp)))
-        } else {
-            let message = format!("status_code: {:?}, error: {}, ", status, resp.text()?);
-            Err(self.error_handle(status, message).await)
-        }
-    }
-
-    async fn error_handle(&self, status: StatusCode, message: String) -> ApiError {
-        if status.is_client_error() {
-            return ApiError::BadRequest(message);
-        }
-
-        if status.is_server_error() {
-            return ApiError::ServerError;
-        }
-
-        if status.is_redirection() {
-            return ApiError::RedirectionError;
-        }
-
-        ApiError::FailedRequest(message)
-    }
 }
 impl RefreshToken for OpenGPT {
     fn refresh_token(&mut self, access_token: String) {
@@ -101,25 +38,12 @@ impl RefreshToken for OpenGPT {
 impl Api for OpenGPT {
     async fn get_models(&self) -> ApiResult<resp::ModelsResponse> {
         let url = format!("{URL_CHATGPT_BASE}/backend-api/models");
-        let payload = self
-            .default_request_builder(url, RequestMethod::GET)
-            .await
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request(payload)?;
-        self.response_handle::<resp::ModelsResponse>(resp).await
+        todo!()
     }
 
     async fn account_check(&self) -> ApiResult<resp::AccountsCheckResponse> {
         let url = format!("{URL_CHATGPT_BASE}/backend-api/accounts/check");
-        let payload = self
-            .default_request_builder(url, RequestMethod::GET)
-            .await
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request(payload)?;
-        self.response_handle::<resp::AccountsCheckResponse>(resp)
-            .await
+        todo!()
     }
 
     async fn get_conversation(
@@ -130,14 +54,7 @@ impl Api for OpenGPT {
             "{URL_CHATGPT_BASE}/backend-api/conversation/{}",
             req.conversation_id
         );
-        let payload = self
-            .default_request_builder(url, RequestMethod::GET)
-            .await
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request(payload)?;
-        self.response_handle::<resp::GetConversationResonse>(resp)
-            .await
+        todo!()
     }
 
     async fn get_conversations(
@@ -148,31 +65,15 @@ impl Api for OpenGPT {
             "{URL_CHATGPT_BASE}/backend-api/conversations?offset={}&limit={}",
             req.offset, req.limit
         );
-        let payload = self
-            .default_request_builder(url, RequestMethod::GET)
-            .await
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request(payload)?;
-        self.response_handle::<resp::GetConversationsResponse>(resp)
-            .await
+        todo!()
     }
 
     async fn create_conversation(
         &self,
         req: req::CreateConversationRequest,
-    ) -> ApiResult<Box<dyn StreamLine<resp::CreateConversationResponse>>> {
+    ) -> ApiResult<resp::CreateConversationResponse> {
         let url = format!("{URL_CHATGPT_BASE}/backend-api/conversation");
-        let body = serde_json::to_string(&req)?;
-        drop(req);
-        let payload = self
-            .default_request_builder(url, RequestMethod::POST)
-            .await
-            .request_body(body)
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request_stream(payload)?;
-        self.response_stream_handle(resp).await
+        todo!()
     }
 
     async fn clear_conversation(
@@ -183,17 +84,7 @@ impl Api for OpenGPT {
             "{URL_CHATGPT_BASE}/backend-api/conversation/{}",
             req.conversation_id
         );
-        let body = serde_json::to_string(&req)?;
-        drop(req);
-        let payload = self
-            .default_request_builder(url, RequestMethod::PATCH)
-            .await
-            .request_body(body)
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request(payload)?;
-        self.response_handle::<resp::ClearConversationResponse>(resp)
-            .await
+        todo!()
     }
 
     async fn clear_conversations(
@@ -201,17 +92,7 @@ impl Api for OpenGPT {
         req: req::ClearConversationRequest,
     ) -> ApiResult<resp::ClearConversationResponse> {
         let url = format!("{URL_CHATGPT_BASE}/backend-api/conversations");
-        let body = serde_json::to_string(&req)?;
-        drop(req);
-        let payload = self
-            .default_request_builder(url, RequestMethod::PATCH)
-            .await
-            .request_body(body)
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request(payload)?;
-        self.response_handle::<resp::ClearConversationResponse>(resp)
-            .await
+        todo!()
     }
 
     async fn rename_conversation(
@@ -222,18 +103,7 @@ impl Api for OpenGPT {
             "{URL_CHATGPT_BASE}/backend-api/conversation/{}",
             req.conversation_id
         );
-        let body =
-            serde_json::to_string(&req).map_err(|err| ApiError::SerializeError(err.to_string()))?;
-        drop(req);
-        let payload = self
-            .default_request_builder(url, RequestMethod::PATCH)
-            .await
-            .request_body(body)
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request(payload)?;
-        self.response_handle::<resp::RenameConversationResponse>(resp)
-            .await
+        todo!()
     }
 
     async fn message_feedback(
@@ -241,17 +111,7 @@ impl Api for OpenGPT {
         req: req::MessageFeedbackRequest,
     ) -> ApiResult<resp::MessageFeedbackResponse> {
         let url = format!("{URL_CHATGPT_BASE}/backend-api/conversation/message_feedback",);
-        let body = serde_json::to_string(&req).map_err(ApiError::SerdeDeserializeError)?;
-        drop(req);
-        let payload = self
-            .default_request_builder(url, RequestMethod::POST)
-            .await
-            .request_body(body)
-            .build()
-            .map_err(|op| ApiError::FailedRequest(op.to_string()))?;
-        let resp = fficall::request(payload)?;
-        self.response_handle::<resp::MessageFeedbackResponse>(resp)
-            .await
+        todo!()
     }
 }
 
@@ -285,7 +145,7 @@ impl OpenGPTBuilder {
 
     pub fn build(self) -> OpenGPT {
         let mut req_headers = HashMap::new();
-        req_headers.insert(reqwest::header::USER_AGENT.to_string(), UA.to_string());
+        req_headers.insert(reqwest_impersonate::header::USER_AGENT.to_string(), UA.to_string());
         OpenGPT {
             access_token: RwLock::new(self.access_token),
             req_headers: req_headers,
