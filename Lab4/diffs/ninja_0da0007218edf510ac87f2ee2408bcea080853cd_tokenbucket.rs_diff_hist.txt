diff --git a/openai/src/serve/tokenbucket.rs b/openai/src/serve/tokenbucket.rs
index 2d04892..d60c69c 100644
--- a/openai/src/serve/tokenbucket.rs
+++ b/openai/src/serve/tokenbucket.rs
@@ -2,7 +2,7 @@ use std::collections::HashMap;
 use std::net::IpAddr;
 use std::sync::Arc;
 use std::time::Instant;
-use tokio::sync::RwLock;
+use tokio::sync::Mutex;
 
 struct BucketState {
     tokens: u32,
@@ -15,20 +15,20 @@ pub struct TokenBucket {
     /// token bucket fill rate `fill_rate`
     fill_rate: u32,
     // ip -> token backet
-    buckets: Arc<RwLock<HashMap<IpAddr, BucketState>>>,
+    buckets: Arc<Mutex<HashMap<IpAddr, BucketState>>>,
     _cleanup_task: tokio::task::JoinHandle<()>,
 }
 
 impl TokenBucket {
     pub fn new(capacity: u32, fill_rate: u32, expired: u32) -> Self {
-        let buckets: Arc<RwLock<HashMap<IpAddr, BucketState>>> =
-            Arc::new(RwLock::new(HashMap::new()));
+        let buckets: Arc<Mutex<HashMap<IpAddr, BucketState>>> =
+            Arc::new(Mutex::new(HashMap::new()));
         let b = buckets.clone();
         let task = tokio::task::spawn(async move {
             loop {
                 tokio::time::sleep(std::time::Duration::from_secs(expired.into())).await;
                 let x = Instant::now();
-                let mut b = b.write().await;
+                let mut b = b.lock().await;
                 b.retain(|_, v| v.last_time > x);
                 drop(b)
             }
@@ -42,18 +42,7 @@ impl TokenBucket {
     }
 
     pub async fn acquire(&self, ip: IpAddr) -> bool {
-        let buckets = self.buckets.read().await;
-        let bucket = buckets.get(&ip);
-        if let Some(bucket) = bucket {
-            let b = bucket.tokens > 0;
-            if b {
-                return b;
-            }
-        }
-        // Release the read lock before acquiring the write lock
-        drop(buckets);
-
-        let mut buckets = self.buckets.write().await;
+        let mut buckets = self.buckets.lock().await;
         let now = Instant::now();
 
         let bucket = buckets.entry(ip).or_insert(BucketState {
