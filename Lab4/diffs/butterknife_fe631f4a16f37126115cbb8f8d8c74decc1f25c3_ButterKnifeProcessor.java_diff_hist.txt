diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
index a6142f6..18dd25a 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
@@ -69,13 +69,13 @@ import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
 
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
-import static javax.tools.Diagnostic.Kind.ERROR;
 
 @AutoService(Processor.class)
 public final class ButterKnifeProcessor extends AbstractProcessor {
@@ -257,7 +257,8 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
 
     // Process each @BindView element.
     for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
+      // we don't SuperficialValidation.validateElement(element)
+      // so that an unresolved View type can be generated by later processing rounds
       try {
         parseBindView(element, targetClassMap, erasedTargetNames);
       } catch (Exception e) {
@@ -267,7 +268,8 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
 
     // Process each @BindViews element.
     for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
+      // we don't SuperficialValidation.validateElement(element)
+      // so that an unresolved View type can be generated by later processing rounds
       try {
         parseBindViews(element, targetClassMap, erasedTargetNames);
       } catch (Exception e) {
@@ -367,11 +369,18 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
       elementType = typeVariable.getUpperBound();
     }
     if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
+      if (elementType.getKind() == TypeKind.ERROR) {
+        note(element, "@%s field with unresolved type (%s) " +
+            "must elsewhere be generated as a View or interface. (%s.%s)",
+            BindView.class.getSimpleName(), elementType, enclosingElement.getQualifiedName(),
+            element.getSimpleName());
+      } else {
         error(element, "@%s fields must extend from View or be an interface. (%s.%s)",
             BindView.class.getSimpleName(), enclosingElement.getQualifiedName(),
             element.getSimpleName());
         hasError = true;
       }
+    }
 
     if (hasError) {
       return;
@@ -446,11 +455,18 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
 
     // Verify that the target type extends from View.
     if (viewType != null && !isSubtypeOfType(viewType, VIEW_TYPE) && !isInterface(viewType)) {
+      if (viewType.getKind() == TypeKind.ERROR) {
+        note(element, "@%s List or array with unresolved type (%s) " +
+            "must elsewhere be generated as a View or interface. (%s.%s)",
+            BindViews.class.getSimpleName(), viewType, enclosingElement.getQualifiedName(),
+            element.getSimpleName());
+      } else {
         error(element, "@%s List or array type must extend from View or be an interface. (%s.%s)",
             BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
             element.getSimpleName());
         hasError = true;
       }
+    }
 
     // Assemble information on the field.
     String name = element.getSimpleName().toString();
@@ -1111,10 +1127,19 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
   }
 
   private void error(Element element, String message, Object... args) {
+    printMessage(Kind.ERROR, element, message, args);
+  }
+
+  private void note(Element element, String message, Object... args) {
+    printMessage(Kind.NOTE, element, message, args);
+  }
+
+  private void printMessage(Kind kind, Element element, String message, Object[] args) {
     if (args.length > 0) {
       message = String.format(message, args);
     }
-    processingEnv.getMessager().printMessage(ERROR, message, element);
+
+    processingEnv.getMessager().printMessage(kind, message, element);
   }
 
   private String getPackageName(TypeElement type) {
