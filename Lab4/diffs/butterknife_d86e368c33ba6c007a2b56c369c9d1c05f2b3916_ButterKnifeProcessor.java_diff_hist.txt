diff --git a/butterknife/src/main/java/butterknife/internal/ButterKnifeProcessor.java b/butterknife/src/main/java/butterknife/internal/ButterKnifeProcessor.java
index e3ae1a1..40259a7 100644
--- a/butterknife/src/main/java/butterknife/internal/ButterKnifeProcessor.java
+++ b/butterknife/src/main/java/butterknife/internal/ButterKnifeProcessor.java
@@ -8,6 +8,7 @@ import butterknife.BindDimen;
 import butterknife.BindDrawable;
 import butterknife.BindInt;
 import butterknife.BindString;
+import butterknife.BindStringArray;
 import butterknife.OnCheckedChanged;
 import butterknife.OnClick;
 import butterknife.OnEditorAction;
@@ -112,6 +113,7 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
     types.add(BindDrawable.class.getCanonicalName());
     types.add(BindInt.class.getCanonicalName());
     types.add(BindString.class.getCanonicalName());
+    types.add(BindStringArray.class.getCanonicalName());
 
     return types;
   }
@@ -210,6 +212,15 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
       }
     }
 
+    // Process each @BindStringArray element.
+    for (Element element : env.getElementsAnnotatedWith(BindStringArray.class)) {
+      try {
+        parseResourceStringArray(element, targetClassMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindStringArray.class, e);
+      }
+    }
+
     // Try to find a parent binder for each.
     for (Map.Entry<TypeElement, BindingClass> entry : targetClassMap.entrySet()) {
       String parentClassFqcn = findParentFqcn(entry.getKey(), erasedTargetNames);
@@ -633,6 +644,38 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
     erasedTargetNames.add(enclosingElement.toString());
   }
 
+  private void parseResourceStringArray(Element element,
+      Map<TypeElement, BindingClass> targetClassMap, Set<String> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is String[].
+    if (!"java.lang.String[]".equals(element.asType().toString())) {
+      error(element, "@%s field type must be 'String[]'. (%s.%s)",
+          BindStringArray.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindStringArray.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindStringArray.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindStringArray.class).value();
+
+    BindingClass bindingClass = getOrCreateTargetClass(targetClassMap, enclosingElement);
+    FieldResourceBinding binding = new FieldResourceBinding(id, name, "getStringArray");
+    bindingClass.addResource(binding);
+
+    erasedTargetNames.add(enclosingElement.toString());
+  }
+
   /** Returns the first duplicate element inside an array, null if there are no duplicates. */
   private static Integer findDuplicate(int[] array) {
     Set<Integer> seenElements = new LinkedHashSet<Integer>();
