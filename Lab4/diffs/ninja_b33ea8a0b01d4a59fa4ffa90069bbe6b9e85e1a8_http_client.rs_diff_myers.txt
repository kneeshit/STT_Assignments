diff --git a/openai/src/serve/preauth/proxy/http_client.rs b/openai/src/serve/preauth/proxy/http_client.rs
index cf5a4a8..141891f 100644
--- a/openai/src/serve/preauth/proxy/http_client.rs
+++ b/openai/src/serve/preauth/proxy/http_client.rs
@@ -1,67 +1,47 @@
-use super::error::Error;
-use hyper::{client::HttpConnector, Client};
-use hyper_proxy::{Proxy as UpstreamProxy, ProxyConnector};
-use rustls::client::{ServerCertVerified, ServerCertVerifier};
-use std::time::SystemTime;
+use http::{response::Builder, Request, Response};
+use hyper::Body;
+use reqwest::impersonate::Impersonate;
 
-use hyper_rustls::{HttpsConnector, HttpsConnectorBuilder};
-use rustls::ClientConfig;
-use std::sync::Arc;
+use super::error::Error;
 
 #[derive(Clone)]
-pub enum HttpClient {
-    Proxy(Client<ProxyConnector<HttpsConnector<HttpConnector>>>),
-    Https(Client<HttpsConnector<HttpConnector>>),
+pub struct HttpClient {
+    inner: reqwest::Client,
 }
 
-pub fn gen_client(upstream_proxy: Option<UpstreamProxy>) -> Result<HttpClient, Error> {
-    let https = {
-        let https_builder = HttpsConnectorBuilder::new()
-            .with_tls_config({
-                let cert_resolver = Arc::new(TrustAllCertVerifier::default());
-                ClientConfig::builder()
-                    .with_safe_defaults()
-                    .with_custom_certificate_verifier(cert_resolver)
-                    .with_no_client_auth()
-            })
-            .https_or_http()
-            .enable_http1()
-            .enable_http2();
-
-        https_builder.build()
-    };
-
-    if let Some(proxy) = upstream_proxy {
-        let connector = ProxyConnector::from_proxy(https, proxy)?;
-        return Ok(HttpClient::Proxy(
-            Client::builder()
-                .http1_title_case_headers(true)
-                .http1_preserve_header_case(true)
-                .build(connector),
-        ));
-    } else {
-        Ok(HttpClient::Https(
-            Client::builder()
-                .http1_title_case_headers(true)
-                .http1_preserve_header_case(true)
-                .build(https),
-        ))
+impl HttpClient {
+    pub fn new(proxy: Option<String>) -> Self {
+        let mut builder = reqwest::Client::builder();
+        if let Some(p) = proxy {
+            builder = builder.proxy(reqwest::Proxy::all(p).expect("faild build proxy"));
         }
+        let inner = builder
+            .impersonate(Impersonate::Chrome99Android)
+            .danger_accept_invalid_certs(true)
+            .build()
+            .expect("faild build reqwest client");
+        Self { inner }
     }
 
-#[derive(Default)]
-struct TrustAllCertVerifier;
+    pub(super) async fn request(&self, req: Request<Body>) -> Result<Response<Body>, Error> {
+        let (method, url) = (req.method().clone(), req.uri().to_string());
+        let (parts, body) = req.into_parts();
+
+        let resp = self
+            .inner
+            .clone()
+            .request(method, url)
+            .body(hyper::body::to_bytes(body).await?)
+            .headers(parts.headers)
+            .send()
+            .await?;
+
+        let mut builder = Builder::new().status(resp.status()).version(resp.version());
+
+        builder
+            .headers_mut()
+            .map(|h| h.extend(resp.headers().clone()));
 
-impl ServerCertVerifier for TrustAllCertVerifier {
-    fn verify_server_cert(
-        &self,
-        _end_entity: &rustls::Certificate,
-        _intermediates: &[rustls::Certificate],
-        _server_name: &rustls::ServerName,
-        _scts: &mut dyn Iterator<Item = &[u8]>,
-        _ocsp_response: &[u8],
-        _n_ow: SystemTime,
-    ) -> Result<ServerCertVerified, rustls::Error> {
-        Ok(ServerCertVerified::assertion())
+        Ok(builder.body(hyper::body::Body::wrap_stream(resp.bytes_stream()))?)
     }
 }
