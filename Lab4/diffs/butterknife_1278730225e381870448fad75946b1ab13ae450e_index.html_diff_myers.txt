diff --git a/website/index.html b/website/index.html
index 703e6e8..2f0cf26 100644
--- a/website/index.html
+++ b/website/index.html
@@ -23,36 +23,7 @@
         <div class="offset4 span8 main">
           <div class="main-inner">
             <h3 id="introduction">Introduction</h3>
-            <p>Android developers, like most developers, are lazy and do not want to write a bunch of code which looks like this:</p>
-            <pre class="prettyprint">class ExampleActivity extends Activity {
-  TextView title;
-  TextView subtitle;
-  TextView footer;
-
-  @Override public void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.simple_activity);
-    title = (TextView) findViewById(R.id.title);
-    subtitle = (TextView) findViewById(R.id.subtitle);
-    footer = (TextView) findViewById(R.id.footer);
-
-    // TODO Use views...
-  }
-}</pre>
-            <p>Instead, they turn to helper libraries that they likely do not fully understand. These libraries might use annotations and magic to allow you to condense your code to:</p>
-            <pre class="prettyprint">class ExampleActivity extends Activity {
-  @Magic(R.id.title) TextView title;
-  @Magic(R.id.subtitle) TextView subtitle;
-  @Magic(R.id.footer) TextView footer;
-
-  @Override public void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.simple_activity);
-    // TODO Use "injected" views...
-  }
-}</pre>
-            <p>While it looks pretty, magic is for children (and it also comes with a heavy runtime penalty).</p>
-            <p>Instead we can leverage a powerful part of the <code>javac</code> compiler to generate the first example's <code>findViewById</code> boilerplate while still allowing us to keep the terseness of the annotations:</p>
+            <p>Annotate fields with <code>@InjectView</code> and a view ID for Butter Knife to find and automatically cast the corresponding view in your layout.</p>
             <pre class="prettyprint">class ExampleActivity extends Activity {
   @InjectView(R.id.title) TextView title;
   @InjectView(R.id.subtitle) TextView subtitle;
@@ -65,13 +36,13 @@
     // TODO Use "injected" views...
   }
 }</pre>
-            <p>In place of magic we now call an <code>inject</code> method. This method delegates to generated code that you can see and debug:</p>
+            <p>Instead of slow reflection, code is generated to perform the view look-ups. Calling <code>inject</code> delegates to this generated code that you can see and debug.</p>
+            <p>The generated code for the above example is roughly equivalent to the following:</p>
             <pre class="prettyprint">public void inject(ExampleActivity activity) {
   activity.subtitle = (android.widget.TextView) activity.findViewById(2130968578);
   activity.footer = (android.widget.TextView) activity.findViewById(2130968579);
   activity.title = (android.widget.TextView) activity.findViewById(2130968577);
 }</pre>
-            <p>Some people call this view injection and lump it along with traditional dependency injection frameworks. They may be wrong in nomenclature, but perhaps there exists some use for it.</p>
 
             <h4 id="non-activity">Non-Activity Injection</h4>
             <p>You can also perform injection on arbitrary objects by supplying your own view root.</p>
@@ -122,6 +93,20 @@
    XML can use it in the <code>onLayoutInflated()</code> callback.</li>
             </ul>
 
+            <h4 id="view-collection">View Collection</h4>
+            <p>You can group multiple views into a <code>List</code> or array.</p>
+            <pre class="prettyprint">@InjectViews({ R.id.first_name, R.id.middle_name, R.id.last_name })
+List&lt;EditText> nameViews;</pre>
+            <p>Use the <code>apply</code> method to set a <a href="https://developer.android.com/reference/android/util/Property.html"><code>Property</code></a> on all of the views.</p>
+            <pre class="prettyprint">ButterKnife.apply(nameViews, View.ALPHA, 0);</pre>
+            <p>The supplied <code>Action</code> interface allows you to perform actions on all of the views in a list as well.</p>
+            <pre class="prettyprint">ButterKnife.apply(nameView, new Action&lt;View>() {
+  @Override public void apply(View view, int index) {
+    view.setAlpha(0);
+    view.animate().alpha(1).setStartDelay(index * 200).setDuration(400);
+  }
+});</pre>
+
             <h4 id="click-injection">Click Listener Injection</h4>
             <p>Click listeners can also automatically be configured onto methods.</p>
             <pre class="prettyprint">@OnClick(R.id.submit)
