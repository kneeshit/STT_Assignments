diff --git a/openai/src/balancer.rs b/openai/src/balancer.rs
index 0df6d58..46c07b6 100644
--- a/openai/src/balancer.rs
+++ b/openai/src/balancer.rs
@@ -1,3 +1,4 @@
+use rand::Rng;
 use reqwest::{impersonate::Impersonate, Client};
 use std::{
     net::IpAddr,
@@ -8,6 +9,44 @@ use std::{
 use crate::{auth, info, HEADER_UA};
 use crate::{auth::AuthClient, context};
 
+#[derive(Clone)]
+pub enum ClientType {
+    Auth(AuthClient),
+    Regular(Client),
+}
+
+impl Into<AuthClient> for ClientType {
+    fn into(self) -> AuthClient {
+        match self {
+            ClientType::Auth(client) => client,
+            _ => panic!("Attempted to convert a non-Auth client into AuthClient"),
+        }
+    }
+}
+
+impl Into<Client> for ClientType {
+    fn into(self) -> Client {
+        match self {
+            ClientType::Regular(client) => client,
+            _ => panic!("Attempted to convert a non-Regular client into Client"),
+        }
+    }
+}
+
+struct Ipv6Subnet {
+    pub ipv6: u128,
+    pub prefix_len: u8,
+}
+
+impl Ipv6Subnet {
+    fn get_random_ipv6(&self) -> IpAddr {
+        let rand: u128 = rand::thread_rng().gen();
+        let net_part = (self.ipv6 >> (128 - self.prefix_len)) << (128 - self.prefix_len);
+        let host_part = (rand << self.prefix_len) >> self.prefix_len;
+        IpAddr::V6((net_part | host_part).into())
+    }
+}
+
 struct Inner {
     disable_direct: bool,
     cookie_store: bool,
@@ -17,10 +56,16 @@ struct Inner {
     tcp_keepalive: Option<Duration>,
     preauth_api: Option<String>,
     proxies: Vec<String>,
+    ipv6_subnet: Option<Ipv6Subnet>,
 }
 
 impl From<&context::ContextArgs> for Inner {
     fn from(args: &context::ContextArgs) -> Self {
+        let ipv6_subnet = args.ipv6_subnet.map(|(ipv6, prefix_len)| Ipv6Subnet {
+            ipv6: ipv6.into(),
+            prefix_len,
+        });
+
         Inner {
             disable_direct: args.disable_direct,
             cookie_store: args.cookie_store,
@@ -30,49 +75,95 @@ impl From<&context::ContextArgs> for Inner {
             pool_idle_timeout: Duration::from_secs(args.pool_idle_timeout as u64),
             preauth_api: args.preauth_api.clone(),
             proxies: args.proxies.clone(),
+            ipv6_subnet,
         }
     }
 }
 
-pub struct ClientLoadBalancer<T: Clone> {
-    clients: Vec<T>,
+pub struct ClientLoadBalancer {
+    clients: Vec<ClientType>,
     index: AtomicUsize,
+    inner: Inner,
 }
 
-impl<T: Clone> ClientLoadBalancer<T> {
-    pub fn new_auth_client(
+impl ClientLoadBalancer {
+    fn new_client_generic<F, T>(
         args: &context::ContextArgs,
-    ) -> anyhow::Result<ClientLoadBalancer<AuthClient>> {
+        client_type: fn(T) -> ClientType,
+        build_fn: F,
+    ) -> anyhow::Result<Self>
+    where
+        F: Fn(&Inner, Option<IpAddr>, Option<&String>) -> T,
+    {
         let inner = Inner::from(args);
+        let mut clients = Vec::with_capacity(inner.proxies.len() + 1);
 
-        Ok(ClientLoadBalancer {
-            clients: build_auth_client(&inner, args.interface),
+        let mut add_client = |proxy: Option<&String>| {
+            let client = build_fn(&inner, args.interface, proxy);
+            clients.push(client_type(client));
+        };
+
+        if inner.proxies.is_empty() || inner.ipv6_subnet.is_some() {
+            add_client(None);
+        } else {
+            if !inner.disable_direct {
+                add_client(None);
+            }
+            for proxy in &inner.proxies {
+                add_client(Some(proxy));
+            }
+        }
+
+        Ok(Self {
+            clients,
             index: AtomicUsize::new(0),
+            inner,
         })
     }
 
-    pub fn new_client(args: &context::ContextArgs) -> anyhow::Result<ClientLoadBalancer<Client>> {
-        let inner = Inner::from(args);
-        let load = ClientLoadBalancer {
-            clients: build_client(&inner, args.interface),
-            index: AtomicUsize::new(0),
-        };
-        Ok(load)
+    pub fn new_auth_client(args: &context::ContextArgs) -> anyhow::Result<Self> {
+        Self::new_client_generic(args, ClientType::Auth, build_auth_client)
     }
 
-    pub fn next(&self) -> T {
-        if self.clients.len() == 1 {
-            return self.clients.first().cloned().expect("Init client failed");
+    pub fn new_client(args: &context::ContextArgs) -> anyhow::Result<Self> {
+        Self::new_client_generic(args, ClientType::Regular, build_client)
     }
+}
+
+impl ClientLoadBalancer {
+    fn rebuild_client_with_ipv6(&self, client: &ClientType) -> ClientType {
+        let bind_addr = self.inner.ipv6_subnet.as_ref().unwrap().get_random_ipv6();
+        match client {
+            ClientType::Auth(_) => {
+                ClientType::Auth(build_auth_client(&self.inner, Some(bind_addr), None))
+            }
+            ClientType::Regular(_) => {
+                ClientType::Regular(build_client(&self.inner, Some(bind_addr), None))
+            }
+        }
+    }
+
+    pub fn next(&self) -> ClientType {
+        match self.clients.len() {
+            1 => {
+                let client = self.clients.first().expect("Init client failed");
+                if self.inner.ipv6_subnet.is_some() {
+                    return self.rebuild_client_with_ipv6(client);
+                }
+                client.clone()
+            }
+            _ => {
                 let len = self.clients.len();
                 let mut old = self.index.load(Ordering::Relaxed);
                 let mut new;
                 loop {
                     new = (old + 1) % len;
-            match self
-                .index
-                .compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed)
-            {
+                    match self.index.compare_exchange_weak(
+                        old,
+                        new,
+                        Ordering::SeqCst,
+                        Ordering::Relaxed,
+                    ) {
                         Ok(_) => break,
                         Err(x) => old = x,
                     }
@@ -80,12 +171,13 @@ impl<T: Clone> ClientLoadBalancer<T> {
                 self.clients[old].clone()
             }
         }
+    }
+}
 
-fn build_client(inner: &Inner, bind_addr: Option<IpAddr>) -> Vec<Client> {
-    let build = |proxy_url: Option<String>| -> reqwest::Client {
-        let mut client_builder = reqwest::Client::builder();
+fn build_client(inner: &Inner, bind_addr: Option<IpAddr>, proxy_url: Option<&String>) -> Client {
+    let mut client_builder = Client::builder();
     if let Some(url) = proxy_url {
-            info!("[Client] Add {url} to proxy");
+        info!("[Client] Add proxy: {url}");
         let proxy = reqwest::Proxy::all(url).expect("Failed to build proxy");
         client_builder = client_builder.proxy(proxy)
     }
@@ -106,31 +198,14 @@ fn build_client(inner: &Inner, bind_addr: Option<IpAddr>) -> Vec<Client> {
         .build()
         .expect("Failed to build API client");
     client
-    };
-
-    let mut clients = Vec::new();
-
-    if inner.proxies.is_empty() {
-        clients.push(build(None));
-    } else {
-        if !inner.disable_direct {
-            clients.push(build(None));
-        }
-        for proxy in inner.proxies.clone() {
-            clients.push(build(Some(proxy)));
-        }
-    }
-    clients
 }
 
-fn build_auth_client(inner: &Inner, bind_addr: Option<IpAddr>) -> Vec<AuthClient> {
-    let build = |proxy_url: Option<String>| -> AuthClient {
-        if proxy_url.is_some() {
-            info!(
-                "[AuthClient] Add {url} to proxy",
-                url = proxy_url.as_ref().unwrap()
-            );
-        }
+fn build_auth_client(
+    inner: &Inner,
+    bind_addr: Option<IpAddr>,
+    proxy_url: Option<&String>,
+) -> AuthClient {
+    proxy_url.map(|url| info!("[AuthClient] Add proxy: {url}"));
     auth::AuthClientBuilder::builder()
         .user_agent(HEADER_UA)
         .impersonate(Impersonate::OkHttpAndroid13)
@@ -138,23 +213,8 @@ fn build_auth_client(inner: &Inner, bind_addr: Option<IpAddr>) -> Vec<AuthClient
         .pool_idle_timeout(inner.pool_idle_timeout.clone())
         .timeout(inner.timeout.clone())
         .connect_timeout(inner.connect_timeout.clone())
-            .proxy(proxy_url)
+        .proxy(proxy_url.cloned())
         .local_address(bind_addr)
         .preauth_api(inner.preauth_api.clone())
         .build()
-    };
-
-    let mut clients = Vec::new();
-    if inner.proxies.is_empty() {
-        clients.push(build(None));
-    } else {
-        if !inner.disable_direct {
-            clients.push(build(None));
-        }
-        for proxy in inner.proxies.clone() {
-            clients.push(build(Some(proxy)));
-        }
-    }
-
-    clients
 }
