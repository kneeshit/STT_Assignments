diff --git a/openai/src/serve/router/arkose.rs b/openai/src/serve/router/arkose.rs
index 0764c41..93d5904 100644
--- a/openai/src/serve/router/arkose.rs
+++ b/openai/src/serve/router/arkose.rs
@@ -4,6 +4,7 @@ use crate::context;
 use crate::context::ContextArgs;
 use crate::serve::error::ResponseError;
 use crate::serve::router::STATIC_FILES;
+use crate::warn;
 use axum::body::Body;
 use axum::http::header;
 use axum::http::method::Method;
@@ -15,6 +16,8 @@ use axum::{
     routing::any,
     Form, Router,
 };
+use bytes::Bytes;
+use http::response::Builder;
 use std::collections::HashMap;
 
 pub(super) fn config(router: Router, args: &ContextArgs) -> Router {
@@ -33,29 +36,26 @@ async fn proxy(
     mut headers: HeaderMap,
     body: Option<Form<HashMap<String, String>>>,
 ) -> Result<impl IntoResponse, ResponseError> {
+    let req_path = uri.path();
+
     if let Some((_, v)) = STATIC_FILES
         .get()
         .expect("static file")
         .iter()
-        .find(|(k, _v)| k.contains(uri.path()))
+        .find(|(k, _v)| k.contains(req_path))
     {
-        let mime_type = if v.mime_type.eq("application/octet-stream") {
+        let mime_type = if v.mime_type == "application/octet-stream" {
             "text/html"
         } else {
             v.mime_type
         };
-        return Ok(Response::builder()
-            .status(StatusCode::OK)
-            .header(header::CONTENT_TYPE, mime_type)
-            .body(Body::from(v.data))
-            .map_err(ResponseError::InternalServerError)?);
+        return create_response(StatusCode::OK, mime_type, v.data);
     }
 
-    let req_path = uri.path();
-
     if req_path.contains("/fc/gt2/public_key/") {
         let pk = req_path.trim_start_matches("/fc/gt2/public_key/");
-        if let Ok(arkose_token) = ArkoseToken::new_from_context(Type::from_pk(pk)?).await {
+        match ArkoseToken::new_from_context(Type::from_pk(pk)?).await {
+            Ok(arkose_token) => {
                 if arkose_token.success() {
                     let target = serde_json::json!({
                         "token": arkose_token,
@@ -80,23 +80,30 @@ async fn proxy(
                             "meta.visual_challenge_frame_title":"视觉挑战"
                         }
                     });
-
-                return Ok(Response::builder()
-                    .status(StatusCode::OK)
-                    .header(header::CONTENT_TYPE, "text/plain; charset=utf-8")
-                    .body(Body::from(target.to_string()))
-                    .map_err(ResponseError::InternalServerError)?);
+                    return create_response(
+                        StatusCode::OK,
+                        "text/plain; charset=utf-8",
+                        target.to_string(),
+                    );
+                }
+            }
+            Err(err) => {
+                warn!("ArkoseToken::new_from_context error: {}", err);
             }
         }
     }
 
-    headers.remove(header::CONNECTION);
-    headers.remove(header::CONTENT_TYPE);
-    headers.remove(header::CONTENT_LENGTH);
+    for header in &[
+        header::CONNECTION,
+        header::CONTENT_TYPE,
+        header::CONTENT_LENGTH,
+    ] {
+        headers.remove(header);
+    }
 
     let client = context::get_instance().client();
+    let url = format!("https://client-api.arkoselabs.com{}", req_path);
 
-    let url = format!("https://client-api.arkoselabs.com{}", uri.path());
     let resp = match body {
         Some(form) => {
             client
@@ -120,7 +127,26 @@ async fn proxy(
         .await
         .map_err(ResponseError::InternalServerError)?;
 
-    Ok(builder
+    Ok(create_response_with_bytes(builder, bytes)?)
+}
+
+fn create_response(
+    status: StatusCode,
+    content_type: &str,
+    data: impl Into<Body>,
+) -> Result<Response<Body>, ResponseError> {
+    Response::builder()
+        .status(status)
+        .header(header::CONTENT_TYPE, content_type)
+        .body(data.into())
+        .map_err(ResponseError::InternalServerError)
+}
+
+fn create_response_with_bytes(
+    builder: Builder,
+    bytes: Bytes,
+) -> Result<Response<Body>, ResponseError> {
+    builder
         .body(Body::from(bytes))
-        .map_err(ResponseError::InternalServerError)?)
+        .map_err(ResponseError::InternalServerError)
 }
