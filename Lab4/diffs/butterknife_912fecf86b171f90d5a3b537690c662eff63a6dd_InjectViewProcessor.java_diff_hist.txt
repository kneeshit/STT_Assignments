diff --git a/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java b/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java
index 407db2f..646d193 100644
--- a/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java
+++ b/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java
@@ -1,11 +1,13 @@
 package butterknife.internal;
 
 import butterknife.InjectView;
+import butterknife.OnClick;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
@@ -15,8 +17,10 @@ import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
@@ -29,7 +33,10 @@ import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
-@SupportedAnnotationTypes("butterknife.InjectView")
+@SupportedAnnotationTypes({ //
+    "butterknife.InjectView", //
+    "butterknife.OnClick" //
+})
 public class InjectViewProcessor extends AbstractProcessor {
   public static final String SUFFIX = "$$ViewInjector";
 
@@ -85,7 +92,7 @@ public class InjectViewProcessor extends AbstractProcessor {
         continue;
       }
 
-      // Verify field properties.
+      // Verify field modifiers.
       Set<Modifier> modifiers = element.getModifiers();
       if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
         error(element, "@InjectView fields must not be private or static (%s.%s).",
@@ -106,21 +113,12 @@ public class InjectViewProcessor extends AbstractProcessor {
         continue;
       }
 
-      TargetClass targetClass = targetClassMap.get(enclosingElement);
-      if (targetClass == null) {
-        String targetType = enclosingElement.getQualifiedName().toString();
-        String classPackage = getPackageName(enclosingElement);
-        String className = getClassName(enclosingElement, classPackage) + SUFFIX;
-
-        targetClass = new TargetClass(classPackage, className, targetType);
-        targetClassMap.put(enclosingElement, targetClass);
-      }
-
       // Assemble information on the injection point.
       String name = element.getSimpleName().toString();
       int id = element.getAnnotation(InjectView.class).value();
       String type = element.asType().toString();
 
+      TargetClass targetClass = getOrCreateTargetClass(targetClassMap, enclosingElement);
       targetClass.addField(id, name, type);
 
       // Add the type-erased version to the valid injection targets set.
@@ -128,6 +126,80 @@ public class InjectViewProcessor extends AbstractProcessor {
       erasedTargetTypes.add(erasedTargetType);
     }
 
+    for (Element element : env.getElementsAnnotatedWith(OnClick.class)) {
+      if (!(element instanceof ExecutableElement)) {
+        error(element, "@OnClick annotation must be on a method.");
+        continue;
+      }
+
+      ExecutableElement executableElement = (ExecutableElement) element;
+      TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+      // Verify method modifiers.
+      Set<Modifier> modifiers = element.getModifiers();
+      if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
+        error(element, "@OnClick methods must not be private or static (%s.%s).",
+            enclosingElement.getQualifiedName(), element);
+        continue;
+      }
+
+      // Verify containing type.
+      if (enclosingElement.getKind() != CLASS) {
+        error(element, "@OnClick method annotations may only be specified in classes (%s).",
+            enclosingElement);
+        continue;
+      }
+
+      // Verify containing class visibility is not private.
+      if (enclosingElement.getModifiers().contains(PRIVATE)) {
+        error(element, "@OnClick methods may not be on private classes (%s).", enclosingElement);
+        continue;
+      }
+
+      // Verify method return type.
+      if (executableElement.getReturnType().getKind() != TypeKind.VOID) {
+        error(element, "@OnClick methods must have a 'void' return type (%s.%s).",
+            enclosingElement.getQualifiedName(), element);
+        continue;
+      }
+
+      String type = null;
+      List<? extends VariableElement> parameters = executableElement.getParameters();
+      if (!parameters.isEmpty()) {
+        // Verify that there is only a single parameter.
+        if (parameters.size() != 1) {
+          error(element,
+              "@OnClick methods may only have one parameter which is View (or subclass) (%s.%s).",
+              enclosingElement.getQualifiedName(), element);
+          continue;
+        }
+        // Verify that the parameter type extends from View.
+        VariableElement variableElement = parameters.get(0);
+        if (!typeUtils.isSubtype(variableElement.asType(), viewType)) {
+          error(element, "@OnClick method parameter must extend from View (%s.%s).",
+              enclosingElement.getQualifiedName(), element);
+          continue;
+        }
+
+        type = variableElement.asType().toString();
+      }
+
+      // Assemble information on the injection point.
+      String name = executableElement.getSimpleName().toString();
+      int id = element.getAnnotation(OnClick.class).value();
+
+      TargetClass targetClass = getOrCreateTargetClass(targetClassMap, enclosingElement);
+      if (!targetClass.addMethod(id, name, type)) {
+        error(element, "Multiple @OnClick methods declared for ID %s in %s.", id,
+            enclosingElement.getQualifiedName());
+        continue;
+      }
+
+      // Add the type-erased version to the valid injection targets set.
+      TypeMirror erasedTargetType = typeUtils.erasure(enclosingElement.asType());
+      erasedTargetTypes.add(erasedTargetType);
+    }
+
     // Try to find a parent injector for each injector.
     for (Map.Entry<TypeElement, TargetClass> entry : targetClassMap.entrySet()) {
       String parentClassFqcn = findParentFqcn(entry.getKey(), erasedTargetTypes);
@@ -139,6 +211,20 @@ public class InjectViewProcessor extends AbstractProcessor {
     return targetClassMap;
   }
 
+  private TargetClass getOrCreateTargetClass(Map<TypeElement, TargetClass> targetClassMap,
+      TypeElement enclosingElement) {
+    TargetClass targetClass = targetClassMap.get(enclosingElement);
+    if (targetClass == null) {
+      String targetType = enclosingElement.getQualifiedName().toString();
+      String classPackage = getPackageName(enclosingElement);
+      String className = getClassName(enclosingElement, classPackage) + SUFFIX;
+
+      targetClass = new TargetClass(classPackage, className, targetType);
+      targetClassMap.put(enclosingElement, targetClass);
+    }
+    return targetClass;
+  }
+
   protected static String getClassName(TypeElement type, String packageName) {
     int packageLen = packageName.length() + 1;
     return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
