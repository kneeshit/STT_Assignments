diff --git a/openai/src/serve/middleware.rs b/openai/src/serve/middleware.rs
index 79b0d20..bd753bc 100644
--- a/openai/src/serve/middleware.rs
+++ b/openai/src/serve/middleware.rs
@@ -65,11 +65,12 @@ where
             Box::pin(async { Ok(ServiceResponse::new(req, resp)) })
         };
 
-        if let Some(token) = authorization {
+        match authorization {
+            Some(token) => {
                 let token = token.clone();
                 let svc = Rc::clone(&self.service);
                 Box::pin(async move {
-                match crate::token::verify_access_token_for_u8(token.as_bytes()).await {
+                    match token::verify_access_token_for_u8(token.as_bytes()).await {
                         Ok(_) => {
                             // forwarded responses map to "left" body
                             svc.call(request)
@@ -79,24 +80,26 @@ where
                         Err(err) => bad_response(&err.to_string(), request).await,
                     }
                 })
-        } else {
-            bad_response("access_token is required!", request)
+            }
+            None => bad_response("access_token is required!", request),
         }
     }
 }
 
+use crate::token;
+
+#[cfg(feature = "sign")]
+use super::sign::Sign;
 #[cfg(feature = "limit")]
 use super::tokenbucket::TokenBucket;
 
 #[cfg(feature = "limit")]
-pub struct TokenBucketRateLimiter {
-    tb: Rc<TokenBucket>,
-}
+pub struct TokenBucketRateLimiter(Rc<TokenBucket>);
 
 #[cfg(feature = "limit")]
 impl TokenBucketRateLimiter {
     pub fn new(tb: TokenBucket) -> Self {
-        Self { tb: Rc::new(tb) }
+        Self(Rc::new(tb))
     }
 }
 
@@ -116,7 +119,7 @@ where
     fn new_transform(&self, service: S) -> Self::Future {
         ready(Ok(TokenBacketMiddleware {
             service: Rc::new(service),
-            tb: self.tb.clone(),
+            tb: self.0.clone(),
         }))
     }
 }
@@ -156,11 +159,11 @@ where
             conn_info.host().parse::<IpAddr>()
         };
 
+        match addr {
+            Ok(addr) => {
                 let svc = self.service.clone();
                 let tb = self.tb.clone();
                 Box::pin(async move {
-            match addr {
-                Ok(addr) => {
                     match tb.acquire(addr).await {
                         true => {
                             // forwarded responses map to "left" body
@@ -170,9 +173,80 @@ where
                         }
                         false => bad_response("Too Many Requests", request).await,
                     }
+                })
+            }
+            Err(err) => bad_response(&err.to_string(), request),
+        }
+    }
+}
+
+pub struct ApiSign(Rc<Option<String>>);
+
+impl ApiSign {
+    pub fn new(s: Option<String>) -> Self {
+        Self(Rc::new(s))
+    }
+}
+
+impl<S, B> Transform<S, ServiceRequest> for ApiSign
+where
+    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
+    S::Future: 'static,
+    B: 'static,
+{
+    type Response = ServiceResponse<EitherBody<B>>;
+    type Error = Error;
+    type InitError = ();
+    type Transform = ApiSignMiddleware<S>;
+    type Future = Ready<Result<Self::Transform, Self::InitError>>;
+
+    fn new_transform(&self, service: S) -> Self::Future {
+        ready(Ok(ApiSignMiddleware {
+            service: service,
+            secret_key: self.0.clone(),
+        }))
     }
-                Err(err) => bad_response(&err.to_string(), request).await,
 }
+pub struct ApiSignMiddleware<S> {
+    service: S,
+    secret_key: Rc<Option<String>>,
+}
+
+impl<S, B> Service<ServiceRequest> for ApiSignMiddleware<S>
+where
+    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
+    S::Future: 'static,
+    B: 'static,
+{
+    type Response = ServiceResponse<EitherBody<B>>;
+    type Error = Error;
+    type Future = LocalBoxFuture<'static, Result<Self::Response, Self::Error>>;
+
+    dev::forward_ready!(service);
+
+    fn call(&self, request: ServiceRequest) -> Self::Future {
+        let ok_response = |request: ServiceRequest| -> Self::Future {
+            let res = self.service.call(request);
+            Box::pin(async move {
+                // forwarded responses map to "left" body
+                res.await.map(ServiceResponse::map_into_left_body)
             })
+        };
+        match self.secret_key.as_deref() {
+            Some(secret_key) => {
+                match Sign::handle_request(&request, secret_key) {
+                    Ok(_) => ok_response(request),
+                    Err(msg) => {
+                        let (req, _) = request.into_parts();
+                        let resp = HttpResponse::BadRequest()
+                            .json(MiddlewareMessage { msg: &msg })
+                            // constructed responses map to "right" body
+                            .map_into_right_body();
+                        Box::pin(async { Ok(ServiceResponse::new(req, resp)) })
+                    }
+                }
+            }
+            None => ok_response(request),
+        }
     }
 }
