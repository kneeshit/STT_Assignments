diff --git a/openai/src/serve/template.rs b/openai/src/serve/template.rs
index 9e53fde..b895c9a 100644
--- a/openai/src/serve/template.rs
+++ b/openai/src/serve/template.rs
@@ -6,13 +6,21 @@ use actix_web::{
     http::header,
     post, web, HttpRequest, HttpResponse, Responder,
 };
+use chrono::TimeZone;
 use serde_json::json;
 
 use crate::auth;
 include!(concat!(env!("OUT_DIR"), "/generated.rs"));
 
+const SESSION_ID: &str = "opengpt_session";
 const BUILD_ID: &str = "cx416mT2Lb0ZTj5FxFg1l";
 
+#[allow(dead_code)]
+struct Session<'a> {
+    token: &'a str,
+    picture: &'a str,
+}
+
 async fn static_service(
     resource_map: web::Data<HashMap<&'static str, ::static_files::Resource>>,
     path: web::Path<String>,
@@ -30,28 +38,31 @@ pub fn config(cfg: &mut web::ServiceConfig) {
     let tera = tera::Tera::new(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/*.html")).unwrap();
     cfg.app_data(web::Data::new(tera))
         .app_data(web::Data::new(generate()))
-        .service(auth0_index)
-        .service(login_index)
-        .service(login_index_post)
-        .service(chat_index)
-        .service(e404_index)
+        .service(get_auth)
+        .service(get_login)
+        .service(post_login)
+        .service(get_logout)
+        .service(get_chat)
+        .service(get_chat_conversation)
+        .service(get_session)
+        .service(get_account_check)
+        .service(e404)
         // static resource endpoints
         .service(
             web::resource("/{filename:.+\\.(png|js|css|webp|json)}")
                 .route(web::get().to(static_service)),
         )
-        .service(chat_conversation_index)
         .service(web::resource("/_next/{tail:.*}").route(web::to(static_service)))
         .service(web::resource("/fonts/{tail:.*}").route(web::to(static_service)))
         .service(web::resource("/ulp/{tail:.*}").route(web::to(static_service)))
         .service(web::resource("/sweetalert2/{tail:.*}").route(web::to(static_service)));
 }
 
-#[get("/auth0")]
-async fn auth0_index(tmpl: web::Data<tera::Tera>) -> impl Responder {
+#[get("/auth")]
+async fn get_auth(tmpl: web::Data<tera::Tera>) -> impl Responder {
     let tm = tmpl
-        .render("auth0.html", &tera::Context::new())
-        .map_err(|_| error::ErrorInternalServerError("Template error"))
+        .render("auth.html", &tera::Context::new())
+        .map_err(|e| error::ErrorInternalServerError(e.to_string()))
         .unwrap();
     HttpResponse::Ok()
         .content_type(header::ContentType::html())
@@ -59,8 +70,8 @@ async fn auth0_index(tmpl: web::Data<tera::Tera>) -> impl Responder {
 }
 
 #[get("/")]
-async fn chat_index(tmpl: web::Data<tera::Tera>, req: HttpRequest) -> impl Responder {
-    match req.cookie("access-token") {
+async fn get_chat(tmpl: web::Data<tera::Tera>, req: HttpRequest) -> impl Responder {
+    match req.cookie(SESSION_ID) {
         Some(cookie) => match crate::token::verify_access_token(cookie.value()).await {
             Ok(token_profile) => match token_profile {
                 Some(profile) => {
@@ -71,8 +82,8 @@ async fn chat_index(tmpl: web::Data<tera::Tera>, req: HttpRequest) -> impl Respo
                                     "id": profile.user_id(),
                                     "name": profile.email(),
                                     "email": profile.email(),
-                                    "image": "",
-                                    "picture": "",
+                                    "image": None::<String>,
+                                    "picture": None::<String>,
                                     "groups": [],
                                 },
                                 "serviceStatus": {},
@@ -94,7 +105,7 @@ async fn chat_index(tmpl: web::Data<tera::Tera>, req: HttpRequest) -> impl Respo
                         "scriptLoader": []
                     });
                     let mut ctx = tera::Context::new();
-                    ctx.insert("props", &props.to_string());
+                    ctx.insert("props", &serde_json::to_string(&props).unwrap());
                     let tm = tmpl
                         .render("chat.html", &ctx)
                         .map_err(|e| error::ErrorInternalServerError(e.to_string()))
@@ -105,20 +116,20 @@ async fn chat_index(tmpl: web::Data<tera::Tera>, req: HttpRequest) -> impl Respo
                 }
                 None => HttpResponse::InternalServerError().finish(),
             },
-            Err(_) => unauthorized_redirect_login(),
+            Err(_) => redirect_login(),
         },
         None => redirect_login(),
     }
 }
 
-#[get("/{conversation_id}")]
-async fn chat_conversation_index(
+#[get("/c/{conversation_id}")]
+async fn get_chat_conversation(
     tmpl: web::Data<tera::Tera>,
     req: HttpRequest,
     mut query: web::Query<HashMap<String, String>>,
     conversation_id: web::Path<String>,
 ) -> impl Responder {
-    match req.cookie("access-token") {
+    match req.cookie(SESSION_ID) {
         Some(cookie) => match crate::token::verify_access_token(cookie.value()).await {
             Ok(token_profile) => match token_profile {
                 Some(profile) => {
@@ -146,7 +157,7 @@ async fn chat_conversation_index(
                             },
                             "__N_SSP": true
                         },
-                        "page": format!("/c/{}", conversation_id),
+                        "page": "/c/[chatId]",
                         "query": hashmap_to_query_string(&query.into_inner()),
                         "buildId": BUILD_ID,
                         "isFallback": false,
@@ -166,14 +177,14 @@ async fn chat_conversation_index(
                 }
                 None => HttpResponse::InternalServerError().finish(),
             },
-            Err(_) => unauthorized_redirect_login(),
+            Err(_) => redirect_login(),
         },
         None => redirect_login(),
     }
 }
 
 #[get("/login")]
-async fn login_index(
+async fn get_login(
     tmpl: web::Data<tera::Tera>,
     query: web::Query<HashMap<String, String>>,
 ) -> impl Responder {
@@ -191,34 +202,34 @@ async fn login_index(
 }
 
 #[post("/login")]
-async fn login_index_post(
+async fn post_login(
     tmpl: web::Data<tera::Tera>,
     query: web::Query<HashMap<String, String>>,
     account: web::Form<auth::OAuthAccount>,
 ) -> impl Responder {
-    let mut ctx = tera::Context::new();
     let default_next = "/".to_owned();
     let next = query.get("next").unwrap_or(&default_next);
-    ctx.insert("next", next.as_str());
-    ctx.insert("username", account.0.username());
-
+    let account = account.into_inner();
     match super::oauth_client()
-        .do_access_token(account.into_inner())
+        .do_access_token(&account)
         .await
     {
         Ok(access_token) => HttpResponse::Found()
-            .insert_header((header::LOCATION, next.as_str()))
-            .content_type(header::ContentType::html())
+            .append_header((header::LOCATION, next.as_str()))
             .cookie(
-                Cookie::build("access-token", access_token.access_token)
+                Cookie::build(SESSION_ID, access_token.access_token)
                     .path("/")
                     .max_age(cookie::time::Duration::seconds(access_token.expires_in))
-                    .secure(true)
+                    .same_site(cookie::SameSite::Lax)
+                    .secure(false)
                     .http_only(true)
                     .finish(),
             )
             .finish(),
         Err(e) => {
+            let mut ctx = tera::Context::new();
+            ctx.insert("next", next.as_str());
+            ctx.insert("username", account.username());
             let tm = tmpl
                 .render("login.html", &ctx)
                 .map_err(|e| error::ErrorInternalServerError(e.to_string()))
@@ -231,8 +242,149 @@ async fn login_index_post(
     }
 }
 
+#[post("/login/token")]
+async fn login_token(req: HttpRequest) -> impl Responder {
+    match req.headers().get(header::AUTHORIZATION) {
+        Some(token) => {
+            match crate::token::verify_access_token(token.to_str().unwrap_or_default()).await {
+                Ok(token_profile) => match token_profile {
+                    Some(profile) => HttpResponse::Found()
+                        .insert_header((header::LOCATION, "/"))
+                        .cookie(
+                            Cookie::build(SESSION_ID, token.to_str().unwrap())
+                                .path("/")
+                                .max_age(cookie::time::Duration::seconds(profile.expires()))
+                                .same_site(cookie::SameSite::Lax)
+                                .secure(false)
+                                .http_only(true)
+                                .finish(),
+                        )
+                        .finish(),
+                    None => HttpResponse::InternalServerError().finish(),
+                },
+                Err(e) => HttpResponse::BadRequest().json(e.to_string()),
+            }
+        }
+        None => redirect_login(),
+    }
+}
+
+#[get("/auth/logout")]
+async fn get_logout(req: HttpRequest) -> impl Responder {
+    match req.cookie(SESSION_ID) {
+        Some(cookie) => {
+            let _ = super::oauth_client().do_revoke_token(cookie.value()).await;
+        }
+        None => {}
+    }
+    HttpResponse::Found()
+        .cookie(
+            Cookie::build(SESSION_ID, "")
+                .path("/")
+                .secure(false)
+                .http_only(true)
+                .finish(),
+        )
+        .insert_header((header::LOCATION, "/login"))
+        .finish()
+}
+
+#[get("/api/auth/session")]
+async fn get_session(req: HttpRequest) -> impl Responder {
+    match req.cookie(SESSION_ID) {
+        Some(cookie) => match crate::token::verify_access_token(cookie.value()).await {
+            Ok(token_profile) => match token_profile {
+                Some(profile) => {
+                    let time = chrono::Utc
+                        .timestamp_millis_opt(profile.expires_at())
+                        .unwrap();
+                    let props = serde_json::json!({
+                        "user": {
+                            "id": profile.user_id(),
+                            "name": profile.email(),
+                            "email": profile.email(),
+                            "image": None::<String>,
+                            "picture": None::<String>,
+                            "groups": [],
+                        },
+                        "expires" : time.format("%Y-%m-%d %H:%M:%S").to_string(),
+                        "accessToken": cookie.value(),
+                        "authProvider": "auth0"
+                    });
+
+                    HttpResponse::Ok().json(props)
+                }
+                None => HttpResponse::InternalServerError().finish(),
+            },
+            Err(_) => redirect_login(),
+        },
+        None => redirect_login(),
+    }
+}
+
+#[get("/api/accounts/check/v4-2023-04-27")]
+async fn get_account_check() -> impl Responder {
+    let res = serde_json::json!({
+        "accounts": {
+            "default": {
+                "account": {
+                    "account_user_role": "account-owner",
+                    "account_user_id": "d0322341-7ace-4484-b3f7-89b03e82b927",
+                    "processor": {
+                        "a001": {
+                            "has_customer_object": true
+                        },
+                        "b001": {
+                            "has_transaction_history": true
+                        }
+                    },
+                    "account_id": "a323bd05-db25-4e8f-9173-2f0c228cc8fa",
+                    "is_most_recent_expired_subscription_gratis": true,
+                    "has_previously_paid_subscription": true
+                },
+                "features": [
+                    "model_switcher",
+                    "model_preview",
+                    "system_message",
+                    "data_controls_enabled",
+                    "data_export_enabled",
+                    "show_existing_user_age_confirmation_modal",
+                    "bucketed_history",
+                    "priority_driven_models_list",
+                    "message_style_202305",
+                    "layout_may_2023",
+                    "plugins_available",
+                    "beta_features",
+                    "infinite_scroll_history",
+                    "browsing_available",
+                    "browsing_inner_monologue",
+                    "browsing_bing_branding",
+                    "shareable_links",
+                    "plugin_display_params",
+                    "tools3_dev",
+                    "tools2",
+                    "debug",
+                ],
+                "entitlement": {
+                    "subscription_id": "d0dcb1fc-56aa-4cd9-90ef-37f1e03576d3",
+                    "has_active_subscription": true,
+                    "subscription_plan": "chatgptplusplan",
+                    "expires_at": "2089-08-08T23:59:59+00:00"
+                },
+                "last_active_subscription": {
+                    "subscription_id": "d0dcb1fc-56aa-4cd9-90ef-37f1e03576d3",
+                    "purchase_origin_platform": "chatgpt_mobile_ios",
+                    "will_renew": true
+                }
+            }
+        },
+        "temp_ap_available_at": "2023-05-20T17:30:00+00:00"
+    });
+    HttpResponse::Ok().json(res)
+}
+
 #[get("/404")]
-async fn e404_index(tmpl: web::Data<tera::Tera>) -> impl Responder {
+async fn e404(tmpl: web::Data<tera::Tera>) -> impl Responder {
     let mut ctx = tera::Context::new();
     let props = json!(
         {
@@ -264,12 +416,6 @@ fn redirect_login() -> HttpResponse {
         .finish()
 }
 
-fn unauthorized_redirect_login() -> HttpResponse {
-    HttpResponse::Unauthorized()
-        .insert_header((header::LOCATION, "/login"))
-        .finish()
-}
-
 fn hashmap_to_query_string(params: &std::collections::HashMap<String, String>) -> String {
     let mut query_string = String::new();
 
