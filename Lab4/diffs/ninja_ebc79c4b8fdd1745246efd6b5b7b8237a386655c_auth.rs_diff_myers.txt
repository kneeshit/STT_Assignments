diff --git a/openai/src/auth.rs b/openai/src/auth.rs
index 06713a3..aeb5265 100644
--- a/openai/src/auth.rs
+++ b/openai/src/auth.rs
@@ -2,14 +2,15 @@ extern crate regex;
 
 use std::collections::HashMap;
 use std::fmt::Debug;
+use std::sync::Arc;
 use std::time::Duration;
 
-use anyhow::bail;
+use anyhow::{bail, Context};
 use async_recursion::async_recursion;
 use derive_builder::Builder;
 use regex::Regex;
 use reqwest::browser::ChromeVersion;
-use reqwest::header::{HeaderMap, HeaderValue};
+use reqwest::header::{HeaderMap, HeaderValue, self};
 use reqwest::redirect::Policy;
 use serde::de::DeserializeOwned;
 use serde::{Deserialize, Serialize};
@@ -17,10 +18,10 @@ use serde::{Deserialize, Serialize};
 use base64::{engine::general_purpose, Engine as _};
 use rand::Rng;
 use reqwest::{Client, Proxy, StatusCode, Url};
-use serde_json::Value;
+use serde_json::{json, Value};
 use sha2::{Digest, Sha256};
 
-use crate::{debug, OAuthError, OAuthResult};
+use crate::{debug, AuthError, AuthResult, URL_CHATGPT_API};
 
 const CLIENT_ID: &str = "pdlLIX2Y72MIl2rhLhTE9VV9bN905kBh";
 const OPENAI_OAUTH_URL: &str = "https://auth0.openai.com";
@@ -30,6 +31,16 @@ const OPENAI_OAUTH_CALLBACK_URL: &str =
     "com.openai.chat://auth0.openai.com/ios/com.openai.chat/callback";
 
 const OPENAI_API_URL: &str = "https://api.openai.com";
+
+pub enum AuthStrategy {
+    IOS,
+    PLATFROM,
+}
+
+#[async_trait::async_trait]
+pub trait AuthHandle: Send + Sync {
+    async fn do_access_token(&self, account: &AuthAccount) -> AuthResult<AccessToken>;
+}
 /// You do **not** have to wrap the `Client` in an [`Rc`] or [`Arc`] to **reuse** it,
 /// because it already uses an [`Arc`] internally.
 ///
@@ -38,10 +49,21 @@ const OPENAI_API_URL: &str = "https://api.openai.com";
 pub struct AuthClient {
     client: Client,
     email_regex: Regex,
+    handle: Arc<Box<dyn AuthHandle + Send + Sync>>,
+}
+
+#[async_trait::async_trait]
+impl AuthHandle for AuthClient {
+    async fn do_access_token(&self, account: &AuthAccount) -> AuthResult<AccessToken> {
+        if !self.email_regex.is_match(&account.username) || account.password.is_empty() {
+            bail!(AuthError::InvalidEmailOrPassword)
+        }
+        self.handle.do_access_token(account).await
+    }
 }
 
 impl AuthClient {
-    pub async fn do_dashboard_login(&self, access_token: &str) -> OAuthResult<DashSession> {
+    pub async fn do_dashboard_login(&self, access_token: &str) -> AuthResult<DashSession> {
         let access_token = access_token.replace("Bearer ", "");
         let resp = self
             .client
@@ -49,11 +71,11 @@ impl AuthClient {
             .bearer_auth(access_token)
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
-        self.response_handle(resp).await
+            .map_err(AuthError::FailedRequest)?;
+        Self::response_handle(resp).await
     }
 
-    pub async fn do_get_api_key(&self, sensitive_id: &str, name: &str) -> OAuthResult<ApiKey> {
+    pub async fn do_get_api_key(&self, sensitive_id: &str, name: &str) -> AuthResult<ApiKey> {
         let data = ApiKeyDataBuilder::default()
             .action("create")
             .name(name)
@@ -65,19 +87,19 @@ impl AuthClient {
             .json(&data)
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
-        self.response_handle(resp).await
+            .map_err(AuthError::FailedRequest)?;
+        Self::response_handle(resp).await
     }
 
-    pub async fn do_get_api_key_list(&self, sensitive_id: &str) -> OAuthResult<ApiKeyList> {
+    pub async fn do_get_api_key_list(&self, sensitive_id: &str) -> AuthResult<ApiKeyList> {
         let resp = self
             .client
             .get(format!("{OPENAI_API_URL}/dashboard/user/api_keys"))
             .bearer_auth(sensitive_id)
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
-        self.response_handle(resp).await
+            .map_err(AuthError::FailedRequest)?;
+        Self::response_handle(resp).await
     }
 
     pub async fn do_delete_api_key(
@@ -85,7 +107,7 @@ impl AuthClient {
         sensitive_id: &str,
         redacted_key: &str,
         created_at: u64,
-    ) -> OAuthResult<ApiKey> {
+    ) -> AuthResult<ApiKey> {
         let data = ApiKeyDataBuilder::default()
             .action("delete")
             .redacted_key(redacted_key)
@@ -98,38 +120,453 @@ impl AuthClient {
             .json(&data)
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
-        self.response_handle(resp).await
+            .map_err(AuthError::FailedRequest)?;
+        Self::response_handle(resp).await
     }
 
-    pub async fn do_access_token(&self, account: &OAuthAccount) -> OAuthResult<AccessToken> {
-        if !self.email_regex.is_match(&account.username) || account.password.is_empty() {
-            bail!(OAuthError::InvalidEmailOrPassword)
+    pub async fn do_refresh_token(&self, refresh_token: &str) -> AuthResult<RefreshToken> {
+        let refresh_token = Self::verify_refresh_token(refresh_token)?;
+        let data = RefreshTokenDataBuilder::default()
+            .redirect_uri(OPENAI_OAUTH_CALLBACK_URL)
+            .grant_type(GrantType::RefreshToken)
+            .client_id(CLIENT_ID)
+            .refresh_token(refresh_token)
+            .build()?;
+
+        let resp = self
+            .client
+            .post(OPENAI_OAUTH_TOKEN_URL)
+            .json(&data)
+            .send()
+            .await?;
+
+        let mut token = Self::response_handle::<RefreshToken>(resp).await?;
+        token.refresh_token = refresh_token.to_owned();
+        Ok(token)
     }
-        let code_verifier = Self::generate_code_verifier();
-        let code_challenge = Self::generate_code_challenge(&code_verifier);
-        let preauth_cookie = self.official_preauth_cookie().await?;
-        let url = format!("https://auth0.openai.com/authorize?state=4DJBNv86mezKHDv-i2wMuDBea2-rHAo5nA_ZT4zJeak&ios_app_version=1744&client_id={CLIENT_ID}&redirect_uri={OPENAI_OAUTH_CALLBACK_URL}&code_challenge={code_challenge}&scope=openid%20email%20profile%20offline_access%20model.request%20model.read%20organization.read%20organization.write&prompt=login&preauth_cookie={preauth_cookie}&audience=https://api.openai.com/v1&code_challenge_method=S256&response_type=code&auth0Client=eyJ2ZXJzaW9uIjoiMi4zLjIiLCJuYW1lIjoiQXV0aDAuc3dpZnQiLCJlbnYiOnsic3dpZnQiOiI1LngiLCJpT1MiOiIxNi4yIn19");
+
+    pub async fn do_revoke_token(&self, refresh_token: &str) -> AuthResult<()> {
+        let refresh_token = Self::verify_refresh_token(refresh_token)?;
+        let data = RevokeTokenDataBuilder::default()
+            .client_id(CLIENT_ID)
+            .token(refresh_token)
+            .build()?;
 
         let resp = self
             .client
-            .get(url)
+            .post(OPENAI_OAUTH_REVOKE_URL)
+            .json(&data)
+            .send()
+            .await
+            .map_err(AuthError::FailedRequest)?;
+
+        Self::response_handle_unit(resp).await
+    }
+
+    async fn response_handle<U: DeserializeOwned>(resp: reqwest::Response) -> AuthResult<U> {
+        let url = resp.url().clone();
+        match resp.error_for_status_ref() {
+            Ok(_) => Ok(resp
+                .json::<U>()
+                .await
+                .map_err(|op| AuthError::DeserializeError(op.to_string()))?),
+            Err(err) => {
+                let err_msg = format!("error: {}, url: {}", resp.text().await?, url);
+                bail!(Self::handle_error(err.status(), err_msg).await)
+            }
+        }
+    }
+
+    async fn response_handle_unit(resp: reqwest::Response) -> AuthResult<()> {
+        let url = resp.url().clone();
+
+        match resp.error_for_status_ref() {
+            Ok(_) => Ok(()),
+            Err(err) => {
+                let err_msg = format!("error: {}, url: {}", resp.text().await?, url);
+                bail!(Self::handle_error(err.status(), err_msg).await)
+            }
+        }
+    }
+
+    async fn handle_error(status: Option<StatusCode>, err_msg: String) -> AuthError {
+        match status {
+            Some(
+                status_code @ (StatusCode::UNAUTHORIZED
+                | StatusCode::REQUEST_TIMEOUT
+                | StatusCode::TOO_MANY_REQUESTS
+                | StatusCode::BAD_REQUEST
+                | StatusCode::PAYMENT_REQUIRED
+                | StatusCode::FORBIDDEN
+                | StatusCode::INTERNAL_SERVER_ERROR
+                | StatusCode::BAD_GATEWAY
+                | StatusCode::SERVICE_UNAVAILABLE
+                | StatusCode::GATEWAY_TIMEOUT),
+            ) => {
+                if status_code == StatusCode::UNAUTHORIZED {
+                    return AuthError::Unauthorized("Unauthorized".to_owned());
+                }
+                if status_code == StatusCode::TOO_MANY_REQUESTS {
+                    return AuthError::TooManyRequests("Too Many Requests".to_owned());
+                }
+                if status_code == StatusCode::BAD_REQUEST {
+                    return AuthError::BadRequest("Bad Request".to_owned());
+                }
+
+                if status_code.is_client_error() {
+                    return AuthError::InvalidClientRequest(err_msg);
+                }
+
+                AuthError::ServerError(err_msg)
+            }
+            _ => AuthError::InvalidRequest("Invalid Request".to_owned()),
+        }
+    }
+
+    fn generate_code_verifier() -> String {
+        let token: [u8; 32] = rand::thread_rng().gen();
+        let code_verifier = general_purpose::URL_SAFE
+            .encode(token)
+            .trim_end_matches('=')
+            .to_string();
+        code_verifier
+    }
+
+    fn generate_code_challenge(code_verifier: &str) -> String {
+        let mut m = Sha256::new();
+        m.update(code_verifier.as_bytes());
+        let code_challenge = general_purpose::URL_SAFE
+            .encode(m.finalize())
+            .trim_end_matches('=')
+            .to_string();
+        code_challenge
+    }
+
+    fn get_callback_code(url: &Url) -> AuthResult<String> {
+        let mut url_params = HashMap::new();
+        url.query_pairs().into_owned().for_each(|(key, value)| {
+            url_params
+                .entry(key)
+                .and_modify(|v: &mut Vec<String>| v.push(value.clone()))
+                .or_insert(vec![value]);
+        });
+
+        debug!("get_callback_code: {:?}", url_params);
+
+        if let Some(error) = url_params.get("error") {
+            if let Some(error_description) = url_params.get("error_description") {
+                let msg = format!("{}: {}", error[0], error_description[0]);
+                bail!("{}", msg)
+            } else {
+                bail!("{}", error[0])
+            }
+        }
+
+        let code = url_params
+            .get("code")
+            .ok_or(AuthError::FailedCallbackCode)?[0]
+            .to_string();
+        Ok(code)
+    }
+
+    fn get_callback_state(url: &Url) -> String {
+        let url_params = url.query_pairs().into_owned().collect::<HashMap<_, _>>();
+        debug!("get_callback_state: {:?}", url_params);
+        url_params["state"].to_owned()
+    }
+
+    fn get_location_path(header: &HeaderMap<HeaderValue>) -> AuthResult<&str> {
+        debug!("get_location_path: {:?}", header);
+        Ok(header
+            .get("Location")
+            .ok_or(AuthError::InvalidLocation)?
+            .to_str()?)
+    }
+
+    fn verify_refresh_token(t: &str) -> AuthResult<&str> {
+        let refresh_token = t.trim_start_matches("Bearer ");
+        if refresh_token.is_empty() {
+            bail!(AuthError::InvalidRefreshToken)
+        }
+        Ok(refresh_token)
+    }
+}
+
+struct PlatformAuthHandle {
+    client: Client,
+}
+
+#[async_trait::async_trait]
+impl AuthHandle for PlatformAuthHandle {
+    async fn do_access_token(&self, account: &AuthAccount) -> AuthResult<AccessToken> {
+        let csrf_token = self.get_csrf_token().await?;
+
+        let authorized_url = self.get_authorized_url(csrf_token).await?;
+
+        let state = AuthClient::get_callback_state(&authorized_url);
+
+        // check username
+        self.authenticate_username(&state, &account.username)
+            .await?;
+
+        // check password and username
+        self.authenticate_password(&state, &account).await?;
+        todo!()
+    }
+}
+
+impl PlatformAuthHandle {
+    async fn get_authorized_url(&self, csrf_token: String) -> AuthResult<Url> {
+        debug!("csrf_token: {csrf_token}");
+        let form = [("callbackUrl", "/"), ("csrfToken", &csrf_token), ("json", "true")];
+        let resp = self
+            .client
+            .post(format!(
+                "{URL_CHATGPT_API}/api/auth/signin/auth0?prompt=login"
+            ))
+            .form(&form)
+            .send()
+            .await
+            .map_err(AuthError::FailedRequest)?;
+
+        println!("{}", resp.status());
+
+        if resp.status().is_success() {
+            let res = resp.json::<Value>().await?;
+            // let url = res
+            //     .as_object()
+            //     .context(AuthError::FailedAuthorizedUrl)?
+            //     .get("url")
+            //     .context(AuthError::FailedAuthorizedUrl)?;
+            println!("url: {}", res);
+        }
+
+        bail!(AuthError::FailedAuthorizedUrl)
+    }
+
+    async fn get_csrf_token(&self) -> AuthResult<String> {
+        let resp = self
+            .client
+            .get(format!("{URL_CHATGPT_API}/api/auth/csrf"))
+            .send()
+            .await
+            .map_err(AuthError::FailedRequest)?;
+        if resp.status().is_success() {
+            let res = resp.json::<Value>().await?;
+            let csrf_token = res
+                .as_object()
+                .context(AuthError::FailedCsrfToken)?
+                .get("csrfToken")
+                .context(AuthError::FailedCsrfToken)?;
+            return Ok(csrf_token.to_string());
+        }
+        bail!(AuthError::FailedCsrfToken)
+    }
+
+    async fn authenticate_username(&self, state: &str, username: &str) -> AuthResult<()> {
+        let url = format!("{OPENAI_OAUTH_URL}/u/login/identifier?state={state}");
+        let resp = self
+            .client
+            .post(&url)
+            .header(reqwest::header::REFERER, HeaderValue::from_str(&url)?)
+            .header(
+                reqwest::header::ORIGIN,
+                HeaderValue::from_static(OPENAI_OAUTH_URL),
+            )
+            .json(
+                &IdentifierDataBuilder::default()
+                    .action("default")
+                    .state(&state)
+                    .username(username)
+                    .js_available(true)
+                    .webauthn_available(true)
+                    .is_brave(false)
+                    .webauthn_platform_available(false)
+                    .build()?,
+            )
+            .send()
+            .await?;
+
+        AuthClient::response_handle_unit(resp)
+            .await
+            .context(AuthError::InvalidEmail)
+    }
+
+    async fn authenticate_password(
+        &self,
+        state: &str,
+        account: &AuthAccount,
+    ) -> AuthResult<AccessToken> {
+        let data = AuthenticateDataBuilder::default()
+            .action("default")
+            .state(state)
+            .username(&account.username)
+            .password(&account.password)
+            .build()?;
+
+        let url = format!("{OPENAI_OAUTH_URL}/u/login/password?state={state}");
+
+        let resp = self
+            .client
+            .post(&url)
+            .json(&data)
+            .send()
+            .await
+            .map_err(AuthError::FailedRequest)?;
+
+        let headers = resp.headers().clone();
+        let status = resp.status();
+
+        AuthClient::response_handle_unit(resp)
+            .await
+            .map_err(|_| AuthError::InvalidEmailOrPassword)?;
+
+        if status.is_redirection() {
+            let location = AuthClient::get_location_path(&headers)?;
+            let resp = self
+                .client
+                .get(format!("{OPENAI_OAUTH_URL}{location}"))
+                .send()
+                .await
+                .map_err(AuthError::FailedRequest)?;
+            if resp.status().is_redirection() {
+                let location = AuthClient::get_location_path(resp.headers())?;
+                if location.starts_with("/u/mfa-otp-challenge") {
+                    let mfa = account.mfa.clone().ok_or(AuthError::MFARequired)?;
+                    return self.authenticate_mfa(&mfa, location, &account).await;
+                }
+                let resp = self
+                    .client
+                    .get(location)
+                    .send()
+                    .await
+                    .map_err(AuthError::FailedRequest)?;
+
+                return match resp.status() {
+                    StatusCode::FOUND => self.get_access_token().await,
+                    StatusCode::TEMPORARY_REDIRECT => {
+                        bail!(AuthError::InvalidEmailOrPassword)
+                    }
+                    _ => {
+                        bail!("Failed to get access token")
+                    }
+                };
+            }
+        }
+        bail!(AuthError::FailedLogin)
+    }
+
+    async fn authenticate_mfa(
+        &self,
+        mfa_code: &str,
+        location: &str,
+        account: &AuthAccount,
+    ) -> AuthResult<AccessToken> {
+        let url = format!("{OPENAI_OAUTH_URL}{}", location);
+        let state = AuthClient::get_callback_state(&Url::parse(&url)?);
+        let data = AuthenticateMfaDataBuilder::default()
+            .action("default")
+            .state(&state)
+            .code(mfa_code)
+            .build()?;
+
+        let resp = self
+            .client
+            .post(&url)
+            .json(&data)
+            .header(reqwest::header::REFERER, HeaderValue::from_str(&url)?)
+            .header(
+                reqwest::header::ORIGIN,
+                HeaderValue::from_static(OPENAI_OAUTH_URL),
+            )
+            .send()
+            .await
+            .map_err(AuthError::FailedRequest)?;
+        let headers = resp.headers().clone();
+
+        AuthClient::response_handle_unit(resp).await?;
+
+        let location: &str = AuthClient::get_location_path(&headers)?;
+        if location.starts_with("/authorize/resume?") && account.mfa.is_none() {
+            bail!(AuthError::MFAFailed)
+        }
+        // self.authenticate_resume(location, &url, &account)
+        //     .await
+        todo!()
+    }
+
+    async fn get_access_token(&self) -> AuthResult<AccessToken> {
+        let resp = self
+            .client
+            .get("https://chat.openai.com/api/auth/session")
+            .send()
+            .await
+            .map_err(AuthError::FailedRequest)?;
+        match resp.status() {
+            StatusCode::OK => Ok(resp.json::<AccessToken>().await?),
+            StatusCode::TOO_MANY_REQUESTS => {
+                bail!(AuthError::TooManyRequests("Too Many Requests".to_owned()))
+            }
+            _ => {
+                bail!("Failed to get access token")
+            }
+        }
+    }
+}
+
+struct IosAuthHandle {
+    client: Client,
+}
+
+#[async_trait::async_trait]
+impl AuthHandle for IosAuthHandle {
+    async fn do_access_token(&self, account: &AuthAccount) -> AuthResult<AccessToken> {
+        let code_verifier = AuthClient::generate_code_verifier();
+        let code_challenge = AuthClient::generate_code_challenge(&code_verifier);
+
+        let url = self
+            .get_authorized_url(&code_challenge)
+            .await?;
+        let state = AuthClient::get_callback_state(&url);
+
+        // check username
+        self.authenticate_username(&state, account).await?;
+
+        // check password and username
+        self.authenticate_password(&code_verifier, &state, account)
+            .await
+    }
+}
+
+impl IosAuthHandle {
+    async fn get_authorized_url(
+        &self,
+        code_challenge: &str,
+    ) -> AuthResult<Url> {
+        let preauth_cookie = self.unofficial_preauth_cookie().await?;
+        let url = format!("https://auth0.openai.com/authorize?state=4DJBNv86mezKHDv-i2wMuDBea2-rHAo5nA_ZT4zJeak&ios_app_version=1744&client_id={CLIENT_ID}&redirect_uri={OPENAI_OAUTH_CALLBACK_URL}&code_challenge={code_challenge}&scope=openid%20email%20profile%20offline_access%20model.request%20model.read%20organization.read%20organization.write&prompt=login&preauth_cookie={preauth_cookie}&audience=https://api.openai.com/v1&code_challenge_method=S256&response_type=code&auth0Client=eyJ2ZXJzaW9uIjoiMi4zLjIiLCJuYW1lIjoiQXV0aDAuc3dpZnQiLCJlbnYiOnsic3dpZnQiOiI1LngiLCJpT1MiOiIxNi4yIn19");
+        let resp = self
+            .client
+            .get(&url)
             .header(
                 reqwest::header::REFERER,
                 HeaderValue::from_static(OPENAI_OAUTH_URL),
             )
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
+            .map_err(AuthError::FailedRequest)?;
+
         let url = resp.url().clone();
 
-        self.response_handle_unit(resp)
+        AuthClient::response_handle_unit(resp)
             .await
-            .map_err(|e| OAuthError::InvalidLoginUrl(e.to_string()))?;
+            .map_err(|e| AuthError::InvalidLoginUrl(e.to_string()))?;
 
-        let state = Self::get_callback_state(&url);
-        let url = format!("{OPENAI_OAUTH_URL}/u/login/identifier?state={state}");
+        Ok(url.clone())
+    }
 
+    async fn authenticate_username(&self, state: &str, account: &AuthAccount) -> AuthResult<()> {
+        let url = format!("{OPENAI_OAUTH_URL}/u/login/identifier?state={state}");
         let resp = self
             .client
             .post(&url)
@@ -152,24 +589,18 @@ impl AuthClient {
             .send()
             .await?;
 
-        let headers = resp.headers().clone();
-        self.response_handle_unit(resp)
-            .await
-            .map_err(|_| OAuthError::InvalidEmail)?;
-
-        let location = Self::get_location_path(&headers)?;
-        self.authenticate_password(&code_verifier, &state, location, &url, account)
+        AuthClient::response_handle_unit(resp)
             .await
+            .context(AuthError::InvalidEmail)
     }
 
     async fn authenticate_password(
         &self,
         code_verifier: &str,
         state: &str,
-        location: &str,
-        referrer: &str,
-        account: &OAuthAccount,
-    ) -> OAuthResult<AccessToken> {
+        account: &AuthAccount,
+    ) -> AuthResult<AccessToken> {
+        debug!("authenticate_password state: {state}");
         let data = AuthenticateDataBuilder::default()
             .action("default")
             .state(state)
@@ -177,59 +608,56 @@ impl AuthClient {
             .password(&account.password)
             .build()?;
 
-        let url = format!("{OPENAI_OAUTH_URL}{location}");
-
         let resp = self
             .client
-            .post(&url)
-            .header(reqwest::header::REFERER, HeaderValue::from_str(referrer)?)
+            .post(format!("{OPENAI_OAUTH_URL}/u/login/password?state={state}"))
             .json(&data)
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
+            .map_err(AuthError::FailedRequest)?;
 
         let headers = resp.headers().clone();
-        self.response_handle_unit(resp)
+        AuthClient::response_handle_unit(resp)
             .await
-            .map_err(|_| OAuthError::InvalidEmailOrPassword)?;
+            .map_err(|_| AuthError::InvalidEmailOrPassword)?;
 
-        let location = Self::get_location_path(&headers)?;
+        let location = AuthClient::get_location_path(&headers)?;
+        debug!("authenticate_password location path: {location}");
         if location.starts_with("/authorize/resume?") {
             return self
-                .authenticate_resume(code_verifier, location, &url, account)
+                .authenticate_resume(code_verifier, location, account)
                 .await;
         }
-        bail!(OAuthError::FailedLogin)
+        bail!(AuthError::FailedLogin)
     }
 
     async fn authenticate_resume(
         &self,
         code_verifier: &str,
         location: &str,
-        referrer: &str,
-        account: &OAuthAccount,
-    ) -> OAuthResult<AccessToken> {
+        account: &AuthAccount,
+    ) -> AuthResult<AccessToken> {
         let resp = self
             .client
             .get(&format!("{OPENAI_OAUTH_URL}{location}"))
-            .header(reqwest::header::REFERER, HeaderValue::from_str(referrer)?)
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
+            .map_err(AuthError::FailedRequest)?;
 
         let headers = resp.headers().clone();
 
-        self.response_handle_unit(resp)
+        AuthClient::response_handle_unit(resp)
             .await
-            .map_err(|_| OAuthError::InvalidLocation)?;
+            .map_err(|_| AuthError::InvalidLocation)?;
 
-        let location: &str = Self::get_location_path(&headers)?;
+        let location: &str = AuthClient::get_location_path(&headers)?;
+        debug!("authenticate_resume location path: {location}");
         if location.starts_with("/u/mfa-otp-challenge?") {
-            let mfa = account.mfa.clone().ok_or(OAuthError::MFARequired)?;
+            let mfa = account.mfa.clone().ok_or(AuthError::MFARequired)?;
             self.authenticate_mfa(&mfa, code_verifier, location, account)
                 .await
         } else if !location.starts_with(OPENAI_OAUTH_CALLBACK_URL) {
-            bail!(OAuthError::FailedCallbackURL)
+            bail!(AuthError::FailedCallbackURL)
         } else {
             self.authorization_code(code_verifier, location).await
         }
@@ -241,10 +669,10 @@ impl AuthClient {
         mfa_code: &str,
         code_verifier: &str,
         location: &str,
-        account: &OAuthAccount,
-    ) -> OAuthResult<AccessToken> {
+        account: &AuthAccount,
+    ) -> AuthResult<AccessToken> {
         let url = format!("{OPENAI_OAUTH_URL}{}", location);
-        let state = Self::get_callback_state(&Url::parse(&url)?);
+        let state = AuthClient::get_callback_state(&Url::parse(&url)?);
         let data = AuthenticateMfaDataBuilder::default()
             .action("default")
             .state(&state)
@@ -262,26 +690,26 @@ impl AuthClient {
             )
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
+            .map_err(AuthError::FailedRequest)?;
         let headers = resp.headers().clone();
 
-        self.response_handle_unit(resp).await?;
+        AuthClient::response_handle_unit(resp).await?;
 
-        let location: &str = Self::get_location_path(&headers)?;
+        let location: &str = AuthClient::get_location_path(&headers)?;
         if location.starts_with("/authorize/resume?") && account.mfa.is_none() {
-            bail!(OAuthError::MFAFailed)
+            bail!(AuthError::MFAFailed)
         }
-        self.authenticate_resume(code_verifier, location, &url, &account)
+        self.authenticate_resume(code_verifier, location, &account)
             .await
     }
 
     async fn authorization_code(
         &self,
         code_verifier: &str,
-        callback_url: &str,
-    ) -> OAuthResult<AccessToken> {
-        let url = Url::parse(callback_url)?;
-        let code = Self::get_callback_code(&url)?;
+        location: &str,
+    ) -> AuthResult<AccessToken> {
+        debug!("authorization_code location path: {location}");
+        let code = AuthClient::get_callback_code(&Url::parse(location)?)?;
         let data = AuthorizationCodeDataBuilder::default()
             .redirect_uri(OPENAI_OAUTH_CALLBACK_URL)
             .grant_type(GrantType::AuthorizationCode)
@@ -296,57 +724,14 @@ impl AuthClient {
             .json(&data)
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
-
-        let access_token = self.response_handle::<AccessToken>(resp).await?;
-        Ok(access_token)
-    }
-
-    pub async fn do_refresh_token(&self, refresh_token: &str) -> OAuthResult<RefreshToken> {
-        let refresh_token = Self::verify_refresh_token(refresh_token)?;
-        let data = RefreshTokenDataBuilder::default()
-            .redirect_uri(OPENAI_OAUTH_CALLBACK_URL)
-            .grant_type(GrantType::RefreshToken)
-            .client_id(CLIENT_ID)
-            .refresh_token(refresh_token)
-            .build()?;
-
-        let resp = self
-            .client
-            .post(OPENAI_OAUTH_TOKEN_URL)
-            .json(&data)
-            .send()
-            .await?;
-
-        let mut token = self.response_handle::<RefreshToken>(resp).await?;
-        token.refresh_token = refresh_token.to_owned();
-        Ok(token)
-    }
-
-    pub async fn do_revoke_token(&self, refresh_token: &str) -> OAuthResult<()> {
-        let refresh_token = Self::verify_refresh_token(refresh_token)?;
-        let data = RevokeTokenDataBuilder::default()
-            .client_id(CLIENT_ID)
-            .token(refresh_token)
-            .build()?;
-
-        let resp = self
-            .client
-            .post(OPENAI_OAUTH_REVOKE_URL)
-            .json(&data)
-            .send()
-            .await
-            .map_err(OAuthError::FailedRequest)?;
+            .map_err(AuthError::FailedRequest)?;
 
-        self.response_handle_unit(resp).await
-    }
+        AuthClient::response_handle::<AccessToken>(resp).await
     }
 
-impl AuthClient {
-
     /// It may fail at any time
     #[allow(dead_code)]
-    async fn official_preauth_cookie(&self) -> OAuthResult<String> {
+    async fn official_preauth_cookie(&self) -> AuthResult<String> {
         let mut kv = HashMap::new();
         kv.insert("bundle_id", "com.openai.chat");
         kv.insert("device_id", "0E92DAF9-94F0-4F77-BDF4-53A60D19EC65");
@@ -359,10 +744,9 @@ impl AuthClient {
             .json(&kv)
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
+            .map_err(AuthError::FailedRequest)?;
 
         if resp.status().is_success() {
-
             if let Some(preauth_cookie) = resp
                 .cookies()
                 .into_iter()
@@ -370,22 +754,21 @@ impl AuthClient {
             {
                 return Ok(preauth_cookie.value().to_owned());
             }
-        } else {
-            let text = resp.text().await?;
-            println!("{}", text);
         }
 
-        bail!(OAuthError::FailedLogin)
+        bail!(AuthError::BadRequest(
+            "Failed to get preauth_devicecheck".to_owned()
+        ))
     }
 
     #[allow(dead_code)]
-    async fn unofficial_preauth_cookie(&self) -> OAuthResult<String> {
+    async fn unofficial_preauth_cookie(&self) -> AuthResult<String> {
         let resp = self
             .client
             .get("https://ai.fakeopen.com/auth/preauth")
             .send()
             .await
-            .map_err(OAuthError::FailedRequest)?;
+            .map_err(AuthError::FailedRequest)?;
 
         if resp.status().is_success() {
             let json = resp.json::<serde_json::Value>().await?;
@@ -400,138 +783,7 @@ impl AuthClient {
             }
         }
 
-        bail!(OAuthError::FailedLogin)
-    }
-
-    async fn response_handle<U: DeserializeOwned>(
-        &self,
-        resp: reqwest::Response,
-    ) -> OAuthResult<U> {
-        let url = resp.url().clone();
-        match resp.error_for_status_ref() {
-            Ok(_) => Ok(resp
-                .json::<U>()
-                .await
-                .map_err(|op| OAuthError::DeserializeError(op.to_string()))?),
-            Err(err) => {
-                let err_msg = format!("error: {}, url: {}", resp.text().await?, url);
-                bail!(self.handle_error(err.status(), err_msg).await)
-            }
-        }
-    }
-
-    async fn response_handle_unit(&self, resp: reqwest::Response) -> OAuthResult<()> {
-        let url = resp.url().clone();
-
-        match resp.error_for_status_ref() {
-            Ok(_) => Ok(()),
-            Err(err) => {
-                let err_msg = format!("error: {}, url: {}", resp.text().await?, url);
-                bail!(self.handle_error(err.status(), err_msg).await)
-            }
-        }
-    }
-
-    async fn handle_error(&self, status: Option<StatusCode>, err_msg: String) -> OAuthError {
-        match status {
-            Some(
-                status_code @ (StatusCode::UNAUTHORIZED
-                | StatusCode::REQUEST_TIMEOUT
-                | StatusCode::TOO_MANY_REQUESTS
-                | StatusCode::BAD_REQUEST
-                | StatusCode::PAYMENT_REQUIRED
-                | StatusCode::FORBIDDEN
-                | StatusCode::INTERNAL_SERVER_ERROR
-                | StatusCode::BAD_GATEWAY
-                | StatusCode::SERVICE_UNAVAILABLE
-                | StatusCode::GATEWAY_TIMEOUT),
-            ) => {
-                if status_code == StatusCode::UNAUTHORIZED {
-                    return OAuthError::Unauthorized("Unauthorized".to_owned());
-                }
-                if status_code == StatusCode::TOO_MANY_REQUESTS {
-                    return OAuthError::TooManyRequests("Too Many Requests".to_owned());
-                }
-                if status_code == StatusCode::BAD_REQUEST {
-                    return OAuthError::BadRequest("Bad Request".to_owned());
-                }
-
-                if status_code.is_client_error() {
-                    return OAuthError::InvalidClientRequest(err_msg);
-                }
-
-                OAuthError::ServerError(err_msg)
-            }
-            _ => OAuthError::InvalidRequest("Invalid Request".to_owned()),
-        }
-    }
-
-    fn generate_code_verifier() -> String {
-        let token: [u8; 32] = rand::thread_rng().gen();
-        let code_verifier = general_purpose::URL_SAFE
-            .encode(token)
-            .trim_end_matches('=')
-            .to_string();
-        code_verifier
-    }
-
-    fn generate_code_challenge(code_verifier: &str) -> String {
-        let mut m = Sha256::new();
-        m.update(code_verifier.as_bytes());
-        let code_challenge = general_purpose::URL_SAFE
-            .encode(m.finalize())
-            .trim_end_matches('=')
-            .to_string();
-        code_challenge
-    }
-
-    fn get_callback_code(url: &Url) -> OAuthResult<String> {
-        let mut url_params = HashMap::new();
-        url.query_pairs().into_owned().for_each(|(key, value)| {
-            url_params
-                .entry(key)
-                .and_modify(|v: &mut Vec<String>| v.push(value.clone()))
-                .or_insert(vec![value]);
-        });
-
-        debug!("get_callback_code: {:?}", url_params);
-
-        if let Some(error) = url_params.get("error") {
-            if let Some(error_description) = url_params.get("error_description") {
-                let msg = format!("{}: {}", error[0], error_description[0]);
-                bail!("{}", msg)
-            } else {
-                bail!("{}", error[0])
-            }
-        }
-
-        let code = url_params
-            .get("code")
-            .ok_or(OAuthError::FailedCallbackCode)?[0]
-            .to_string();
-        Ok(code)
-    }
-
-    fn get_callback_state(url: &Url) -> String {
-        let url_params = url.query_pairs().into_owned().collect::<HashMap<_, _>>();
-        debug!("get_callback_state: {:?}", url_params);
-        url_params["state"].to_owned()
-    }
-
-    fn get_location_path(header: &HeaderMap<HeaderValue>) -> OAuthResult<&str> {
-        debug!("get_location_path: {:?}", header);
-        Ok(header
-            .get("Location")
-            .ok_or(OAuthError::InvalidLocation)?
-            .to_str()?)
-    }
-
-    fn verify_refresh_token(t: &str) -> OAuthResult<&str> {
-        let refresh_token = t.trim_start_matches("Bearer ");
-        if refresh_token.is_empty() {
-            bail!(OAuthError::InvalidRefreshToken)
-        }
-        Ok(refresh_token)
+        bail!(AuthError::FailedLogin)
     }
 }
 
@@ -623,6 +875,7 @@ pub struct AccessToken {
     pub refresh_token: String,
     pub id_token: String,
     pub expires_in: i64,
+    pub puid: Option<String>,
 }
 
 #[derive(Debug, Serialize, Deserialize)]
@@ -635,14 +888,14 @@ pub struct RefreshToken {
 }
 
 #[derive(Deserialize, Builder)]
-pub struct OAuthAccount {
+pub struct AuthAccount {
     username: String,
     password: String,
     #[builder(setter(into, strip_option), default)]
     mfa: Option<String>,
 }
 
-impl OAuthAccount {
+impl AuthAccount {
     pub fn username(&self) -> &str {
         self.username.as_ref()
     }
@@ -656,11 +909,6 @@ impl OAuthAccount {
     }
 }
 
-pub struct AuthClientBuilder {
-    builder: reqwest::ClientBuilder,
-    oauth: AuthClient,
-}
-
 #[derive(Debug, Deserialize)]
 pub struct DashSession {
     pub object: String,
@@ -736,21 +984,18 @@ pub struct OrgsData {
 }
 
 #[derive(Debug, Deserialize)]
-#[serde(rename_all = "camelCase")]
 pub struct ApiKey {
     pub result: String,
     pub key: Option<Key>,
 }
 
 #[derive(Debug, Deserialize)]
-#[serde(rename_all = "camelCase")]
 pub struct ApiKeyList {
     pub object: String,
     pub data: Vec<Key>,
 }
 
 #[derive(Debug, Deserialize)]
-#[serde(rename_all = "camelCase")]
 pub struct Key {
     #[serde(rename = "sensitive_id")]
     pub sensitive_id: String,
@@ -762,6 +1007,11 @@ pub struct Key {
     pub publishable: bool,
 }
 
+pub struct AuthClientBuilder {
+    builder: reqwest::ClientBuilder,
+    strategy: AuthStrategy,
+}
+
 impl AuthClientBuilder {
     // Proxy options
     pub fn proxy(mut self, proxy: Option<String>) -> Self {
@@ -860,9 +1110,36 @@ impl AuthClientBuilder {
         self
     }
 
-    pub fn build(mut self) -> AuthClient {
-        self.oauth.client = self.builder.build().expect("ClientBuilder::build()");
-        self.oauth
+    /// Handle auth strategy, default is `AuthStrategy::IOS`
+    pub fn handle(mut self, strategy: AuthStrategy) -> Self {
+        self.strategy = strategy;
+        self
+    }
+
+    pub fn build(self) -> AuthClient {
+        let client = self.builder.build().expect("ClientBuilder::build()");
+
+        let handle: Box<dyn AuthHandle + Send + Sync> = match self.strategy {
+            AuthStrategy::IOS => {
+                let handle = IosAuthHandle {
+                    client: client.clone(),
+                };
+                Box::new(handle)
+            }
+            AuthStrategy::PLATFROM => {
+                let handle = PlatformAuthHandle {
+                    client: client.clone(),
+                };
+                Box::new(handle)
+            }
+        };
+
+        AuthClient {
+            client,
+            email_regex: Regex::new(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,7}\b")
+                .expect("Regex::new()"),
+            handle: Arc::new(handle),
+        }
     }
 
     pub fn builder() -> AuthClientBuilder {
@@ -878,14 +1155,9 @@ impl AuthClientBuilder {
                 attempt.stop()
             }
         }));
-
         AuthClientBuilder {
             builder: client_builder,
-            oauth: AuthClient {
-                client: Client::new(),
-                email_regex: Regex::new(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,7}\b")
-                    .expect("Regex::new()"),
-            },
+            strategy: AuthStrategy::PLATFROM,
         }
     }
 }
