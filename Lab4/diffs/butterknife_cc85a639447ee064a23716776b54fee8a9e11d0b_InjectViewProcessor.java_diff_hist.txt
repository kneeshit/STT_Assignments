diff --git a/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java b/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java
index 91bb136..02440db 100644
--- a/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java
+++ b/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java
@@ -83,14 +83,44 @@ public class InjectViewProcessor extends AbstractProcessor {
     Map<TypeElement, TargetClass> targetClassMap = new LinkedHashMap<TypeElement, TargetClass>();
     Set<TypeMirror> erasedTargetTypes = new LinkedHashSet<TypeMirror>();
 
+    // Process each @InjectView elements.
     for (Element element : env.getElementsAnnotatedWith(InjectView.class)) {
+      try {
+        parseInjectView(element, targetClassMap, erasedTargetTypes);
+      } catch (Exception e) {
+        error(element, "Unable to parse @InjectView: %s", e.getMessage());
+      }
+    }
+
+    // Process each @OnClick elements.
+    for (Element element : env.getElementsAnnotatedWith(OnClick.class)) {
+      try {
+        parseOnClick(element, targetClassMap, erasedTargetTypes);
+      } catch (Exception e) {
+        error(element, "Unable to parse @OnClick: %s", e.getMessage());
+      }
+    }
+
+    // Try to find a parent injector for each injector.
+    for (Map.Entry<TypeElement, TargetClass> entry : targetClassMap.entrySet()) {
+      String parentClassFqcn = findParentFqcn(entry.getKey(), erasedTargetTypes);
+      if (parentClassFqcn != null) {
+        entry.getValue().setParentInjector(parentClassFqcn + SUFFIX);
+      }
+    }
+
+    return targetClassMap;
+  }
+
+  private void parseInjectView(Element element, Map<TypeElement, TargetClass> targetClassMap,
+      Set<TypeMirror> erasedTargetTypes) {
     TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
     // Verify that the target type extends from View.
     if (!typeUtils.isSubtype(element.asType(), viewType)) {
       error(element, "@InjectView fields must extend from View (%s.%s).",
           enclosingElement.getQualifiedName(), element);
-        continue;
+      return;
     }
 
     // Verify field modifiers.
@@ -98,20 +128,20 @@ public class InjectViewProcessor extends AbstractProcessor {
     if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
       error(element, "@InjectView fields must not be private or static (%s.%s).",
           enclosingElement.getQualifiedName(), element);
-        continue;
+      return;
     }
 
     // Verify containing type.
     if (enclosingElement.getKind() != CLASS) {
       error(element, "@InjectView field annotations may only be specified in classes (%s).",
           enclosingElement);
-        continue;
+      return;
     }
 
     // Verify containing class visibility is not private.
     if (enclosingElement.getModifiers().contains(PRIVATE)) {
       error(element, "@InjectView fields may not be on private classes (%s).", enclosingElement);
-        continue;
+      return;
     }
 
     // Assemble information on the injection point.
@@ -128,10 +158,11 @@ public class InjectViewProcessor extends AbstractProcessor {
     erasedTargetTypes.add(erasedTargetType);
   }
 
-    for (Element element : env.getElementsAnnotatedWith(OnClick.class)) {
+  private void parseOnClick(Element element, Map<TypeElement, TargetClass> targetClassMap,
+      Set<TypeMirror> erasedTargetTypes) {
     if (!(element instanceof ExecutableElement)) {
       error(element, "@OnClick annotation must be on a method.");
-        continue;
+      return;
     }
 
     ExecutableElement executableElement = (ExecutableElement) element;
@@ -142,27 +173,27 @@ public class InjectViewProcessor extends AbstractProcessor {
     if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
       error(element, "@OnClick methods must not be private or static (%s.%s).",
           enclosingElement.getQualifiedName(), element);
-        continue;
+      return;
     }
 
     // Verify containing type.
     if (enclosingElement.getKind() != CLASS) {
       error(element, "@OnClick method annotations may only be specified in classes (%s).",
           enclosingElement);
-        continue;
+      return;
     }
 
     // Verify containing class visibility is not private.
     if (enclosingElement.getModifiers().contains(PRIVATE)) {
       error(element, "@OnClick methods may not be on private classes (%s).", enclosingElement);
-        continue;
+      return;
     }
 
     // Verify method return type.
     if (executableElement.getReturnType().getKind() != TypeKind.VOID) {
       error(element, "@OnClick methods must have a 'void' return type (%s.%s).",
           enclosingElement.getQualifiedName(), element);
-        continue;
+      return;
     }
 
     String type = null;
@@ -173,14 +204,14 @@ public class InjectViewProcessor extends AbstractProcessor {
         error(element,
             "@OnClick methods may only have one parameter which is View (or subclass) (%s.%s).",
             enclosingElement.getQualifiedName(), element);
-          continue;
+        return;
       }
       // Verify that the parameter type extends from View.
       VariableElement variableElement = parameters.get(0);
       if (!typeUtils.isSubtype(variableElement.asType(), viewType)) {
         error(element, "@OnClick method parameter must extend from View (%s.%s).",
             enclosingElement.getQualifiedName(), element);
-          continue;
+        return;
       }
 
       type = variableElement.asType().toString();
@@ -193,39 +224,24 @@ public class InjectViewProcessor extends AbstractProcessor {
 
     TargetClass targetClass = getOrCreateTargetClass(targetClassMap, enclosingElement);
 
-      boolean bad = false;
     Set<Integer> seenIds = new LinkedHashSet<Integer>();
     for (int id : ids) {
       if (!seenIds.add(id)) {
         error(element, "@OnClick annotation for method %s contains duplicate ID %s.", element,
             id);
-          bad = true;
+        return;
       } else if (!targetClass.addMethod(id, name, type, required)) {
         error(element, "Multiple @OnClick methods declared for ID %s in %s.", id,
             enclosingElement.getQualifiedName());
-          bad = true;
+        return;
       }
     }
-      if (bad) {
-        continue;
-      }
 
     // Add the type-erased version to the valid injection targets set.
     TypeMirror erasedTargetType = typeUtils.erasure(enclosingElement.asType());
     erasedTargetTypes.add(erasedTargetType);
   }
 
-    // Try to find a parent injector for each injector.
-    for (Map.Entry<TypeElement, TargetClass> entry : targetClassMap.entrySet()) {
-      String parentClassFqcn = findParentFqcn(entry.getKey(), erasedTargetTypes);
-      if (parentClassFqcn != null) {
-        entry.getValue().setParentInjector(parentClassFqcn + SUFFIX);
-      }
-    }
-
-    return targetClassMap;
-  }
-
   private TargetClass getOrCreateTargetClass(Map<TypeElement, TargetClass> targetClassMap,
       TypeElement enclosingElement) {
     TargetClass targetClass = targetClassMap.get(enclosingElement);
