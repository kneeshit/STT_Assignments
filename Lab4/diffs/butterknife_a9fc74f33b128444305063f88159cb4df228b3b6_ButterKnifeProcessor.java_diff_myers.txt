diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
index 76b5e91..c31a994 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
@@ -62,9 +62,6 @@ import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import rx.Observable;
-import rx.functions.Func1;
-import rx.schedulers.Schedulers;
 
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
@@ -261,81 +258,18 @@ public final class ButterKnifeProcessor extends AbstractProcessor {
     }
 
     // Try to find a parent binder for each.
-    Set<BindingClass> topLevelClasses = new LinkedHashSet<>();
     for (Map.Entry<TypeElement, BindingClass> entry : targetClassMap.entrySet()) {
       TypeElement parentType = findParentType(entry.getKey(), erasedTargetNames);
       if (parentType != null) {
         BindingClass bindingClass = entry.getValue();
         BindingClass parentBindingClass = targetClassMap.get(parentType);
         bindingClass.setParent(parentBindingClass);
-        parentBindingClass.addDescendant(bindingClass);
-      } else {
-        // This is a top level parent.
-        topLevelClasses.add(entry.getValue());
-      }
       }
-
-    Observable.from(topLevelClasses)
-        .flatMap(new Func1<BindingClass, Observable<?>>() {
-          @Override public Observable<?> call(BindingClass topLevelClass) {
-            if (topLevelClass.hasViewBindings()) {
-              // It has an unbinder class and it will also be the highest unbinder class for all
-              // descendants.
-              topLevelClass.setHighestUnbinderClassName(topLevelClass.getUnbinderClassName());
-            } else {
-              // No unbinder class, so null it out so we know we can just return the NOP unbinder.
-              topLevelClass.setUnbinderClassName(null);
     }
 
-            // Recursively set up parent unbinding relationships on all its descendants.
-            return ButterKnifeProcessor.this.setParentUnbindingRelationships(
-                topLevelClass.getDescendants());
-          }
-        })
-        .toCompletable()
-        .await();
-
     return targetClassMap;
   }
 
-  /**
-   * Recurse through descendants and set up unbinder inheritance relationships.
-   * This can be multithreaded because there's no multiple inheritance. For small projects, the
-   * difference is negligible. For larger projects though, the overhead of switching schedulers is
-   * amortized. This could especially make a difference for base activities and base fragments.
-   */
-  private Observable<BindingClass> setParentUnbindingRelationships(
-      Iterable<BindingClass> bindings) {
-    return Observable.from(bindings)
-        .flatMap(new Func1<BindingClass, Observable<? extends BindingClass>>() {
-          @Override public Observable<? extends BindingClass> call(BindingClass binding) {
-            if (binding.hasViewBindings()) {
-              // The descendant has its own unbinder class.
-              if (binding.getParentBinding().getHighestUnbinderClassName() != null) {
-                // The descendant is not the first to have its own unbinder class, so its highest
-                // unbinder reference should point to the first.
-                binding.setHighestUnbinderClassName(
-                    binding.getParentBinding().getHighestUnbinderClassName());
-              } else {
-                // This descendant is the first to have its own unbinder class, so it will also
-                // be the highest.
-                binding.setHighestUnbinderClassName(binding.getUnbinderClassName());
-              }
-            } else {
-              // The descendant has no unbinder class, so just defer it unbinder class and highest
-              // unbinder class to the parent's. This way, future descendants looking at this one
-              // will just use the parent's.
-              binding.setUnbinderClassName(binding.getParentBinding().getUnbinderClassName());
-              binding.setHighestUnbinderClassName(
-                  binding.getParentBinding().getHighestUnbinderClassName());
-            }
-            return ButterKnifeProcessor.this.setParentUnbindingRelationships(
-                binding.getDescendants());
-          }
-        })
-        .subscribeOn(Schedulers.computation());
-  }
-
   private void logParsingError(Element element, Class<? extends Annotation> annotation,
       Exception e) {
     StringWriter stackTrace = new StringWriter();
