diff --git a/dist/alpine-ie11.js b/dist/alpine-ie11.js
index bea23868..53d007fb 100644
--- a/dist/alpine-ie11.js
+++ b/dist/alpine-ie11.js
@@ -4429,10 +4429,48 @@
     }
   });
 
-  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('splice');
-  var USES_TO_LENGTH$7 = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });
+  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');
+  var USES_TO_LENGTH$7 = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });
 
+  var SPECIES$6 = wellKnownSymbol('species');
+  var nativeSlice = [].slice;
   var max$1 = Math.max;
+
+  // `Array.prototype.slice` method
+  // https://tc39.github.io/ecma262/#sec-array.prototype.slice
+  // fallback for not array-like ES3 strings and DOM objects
+  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$7 }, {
+    slice: function slice(start, end) {
+      var O = toIndexedObject(this);
+      var length = toLength(O.length);
+      var k = toAbsoluteIndex(start, length);
+      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
+      // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
+      var Constructor, result, n;
+      if (isArray(O)) {
+        Constructor = O.constructor;
+        // cross-realm fallback
+        if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
+          Constructor = undefined;
+        } else if (isObject(Constructor)) {
+          Constructor = Constructor[SPECIES$6];
+          if (Constructor === null) Constructor = undefined;
+        }
+        if (Constructor === Array || Constructor === undefined) {
+          return nativeSlice.call(O, k, fin);
+        }
+      }
+      result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
+      for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
+      result.length = n;
+      return result;
+    }
+  });
+
+  var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');
+  var USES_TO_LENGTH$8 = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });
+
+  var max$2 = Math.max;
   var min$3 = Math.min;
   var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
   var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';
@@ -4440,7 +4478,7 @@
   // `Array.prototype.splice` method
   // https://tc39.github.io/ecma262/#sec-array.prototype.splice
   // with adding support of @@species
-  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$7 }, {
+  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$8 }, {
     splice: function splice(start, deleteCount /* , ...items */) {
       var O = toObject(this);
       var len = toLength(O.length);
@@ -4454,7 +4492,7 @@
         actualDeleteCount = len - actualStart;
       } else {
         insertCount = argumentsLength - 2;
-        actualDeleteCount = min$3(max$1(toInteger(deleteCount), 0), len - actualStart);
+        actualDeleteCount = min$3(max$2(toInteger(deleteCount), 0), len - actualStart);
       }
       if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
         throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
@@ -4693,7 +4731,7 @@
     }
   });
 
-  var max$2 = Math.max;
+  var max$3 = Math.max;
   var min$4 = Math.min;
   var floor$1 = Math.floor;
   var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
@@ -4759,7 +4797,7 @@
           result = results[i];
 
           var matched = String(result[0]);
-          var position = max$2(min$4(toInteger(result.index), S.length), 0);
+          var position = max$3(min$4(toInteger(result.index), S.length), 0);
           var captures = [];
           // NOTE: This is equivalent to
           //   captures = result.slice(1).map(maybeToString)
@@ -5330,6 +5368,15 @@
       }.bind(this));
     }.bind(this));
   }
+  function getTargetFromPropertiesPath(path, parent, context) {
+    var child = parent[path[0]];
+
+    if (_typeof(child) === 'object' && path.length > 1) {
+      return getTargetFromPropertiesPath(path.slice(1), context.membrane.unwrapProxy(child), context);
+    }
+
+    return _typeof(child) === 'object' ? child : parent;
+  }
 
   function isNumeric(subject) {
     return !isNaN(subject);
@@ -6392,14 +6439,22 @@
           valueMutated: function valueMutated(target, key) {
             var _this3 = this;
 
-            if (self.watchers[key]) {
-              self.watchers[key].forEach(function (callback) {
+            Object.keys(self.watchers).forEach(function (watcherKey) {
+              var _this4 = this;
+
               _newArrowCheck(this, _this3);
 
+              var watcherKeyPath = watcherKey.split('.');
+              var watcherTarget = getTargetFromPropertiesPath(watcherKeyPath, self.membrane.unwrapProxy(self.$data), self);
+
+              if (target === watcherTarget && key === watcherKeyPath[watcherKeyPath.length - 1]) {
+                self.watchers[watcherKey].forEach(function (callback) {
+                  _newArrowCheck(this, _this4);
+
                   return callback(target[key]);
                 }.bind(this));
-            } // Don't react to data changes for cases like the `x-created` hook.
-
+              }
+            }.bind(this)); // Don't react to data changes for cases like the `x-created` hook.
 
             if (self.pauseReactivity) return;
             debounce(function () {
@@ -6421,13 +6476,13 @@
     }, {
       key: "walkAndSkipNestedComponents",
       value: function walkAndSkipNestedComponents(el, callback) {
-        var _this4 = this;
+        var _this5 = this;
 
         var initializeComponentCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
-          _newArrowCheck(this, _this4);
+          _newArrowCheck(this, _this5);
         }.bind(this);
         walk(el, function (el) {
-          _newArrowCheck(this, _this4);
+          _newArrowCheck(this, _this5);
 
           // We've hit a component.
           if (el.hasAttribute('x-data')) {
@@ -6446,19 +6501,19 @@
     }, {
       key: "initializeElements",
       value: function initializeElements(rootEl) {
-        var _this5 = this;
+        var _this6 = this;
 
         var extraVars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
-          _newArrowCheck(this, _this5);
+          _newArrowCheck(this, _this6);
         }.bind(this);
         this.walkAndSkipNestedComponents(rootEl, function (el) {
-          _newArrowCheck(this, _this5);
+          _newArrowCheck(this, _this6);
 
           // Don't touch spawns from for loop
           if (el.__x_for_key !== undefined) return false;
           this.initializeElement(el, extraVars);
         }.bind(this), function (el) {
-          _newArrowCheck(this, _this5);
+          _newArrowCheck(this, _this6);
 
           el.__x = new Component(el);
         }.bind(this));
@@ -6483,19 +6538,19 @@
     }, {
       key: "updateElements",
       value: function updateElements(rootEl) {
-        var _this6 = this;
+        var _this7 = this;
 
         var extraVars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
-          _newArrowCheck(this, _this6);
+          _newArrowCheck(this, _this7);
         }.bind(this);
         this.walkAndSkipNestedComponents(rootEl, function (el) {
-          _newArrowCheck(this, _this6);
+          _newArrowCheck(this, _this7);
 
           // Don't touch spawns from for loop (and check if the root is actually a for loop in a parent, don't skip it.)
           if (el.__x_for_key !== undefined && !el.isSameNode(this.$el)) return false;
           this.updateElement(el, extraVars);
         }.bind(this), function (el) {
-          _newArrowCheck(this, _this6);
+          _newArrowCheck(this, _this7);
 
           el.__x = new Component(el);
         }.bind(this));
@@ -6508,45 +6563,45 @@
     }, {
       key: "executeAndClearRemainingShowDirectiveStack",
       value: function executeAndClearRemainingShowDirectiveStack() {
-        var _this7 = this;
+        var _this8 = this;
 
         // The goal here is to start all the x-show transitions
         // and build a nested promise chain so that elements
         // only hide when the children are finished hiding.
         this.showDirectiveStack.reverse().map(function (thing) {
-          var _this8 = this;
+          var _this9 = this;
 
-          _newArrowCheck(this, _this7);
+          _newArrowCheck(this, _this8);
 
           return new Promise(function (resolve) {
-            var _this9 = this;
+            var _this10 = this;
 
-            _newArrowCheck(this, _this8);
+            _newArrowCheck(this, _this9);
 
             thing(function (finish) {
-              _newArrowCheck(this, _this9);
+              _newArrowCheck(this, _this10);
 
               resolve(finish);
             }.bind(this));
           }.bind(this));
         }.bind(this)).reduce(function (nestedPromise, promise) {
-          var _this10 = this;
+          var _this11 = this;
 
-          _newArrowCheck(this, _this7);
+          _newArrowCheck(this, _this8);
 
           return nestedPromise.then(function () {
-            var _this11 = this;
+            var _this12 = this;
 
-            _newArrowCheck(this, _this10);
+            _newArrowCheck(this, _this11);
 
             return promise.then(function (finish) {
-              _newArrowCheck(this, _this11);
+              _newArrowCheck(this, _this12);
 
               return finish();
             }.bind(this));
           }.bind(this));
         }.bind(this), Promise.resolve(function () {
-          _newArrowCheck(this, _this7);
+          _newArrowCheck(this, _this8);
         }.bind(this))); // We've processed the handler stack. let's clear it.
 
         this.showDirectiveStack = [];
@@ -6560,7 +6615,7 @@
     }, {
       key: "registerListeners",
       value: function registerListeners(el, extraVars) {
-        var _this12 = this;
+        var _this13 = this;
 
         getXAttrs(el).forEach(function (_ref) {
           var type = _ref.type,
@@ -6568,7 +6623,7 @@
               modifiers = _ref.modifiers,
               expression = _ref.expression;
 
-          _newArrowCheck(this, _this12);
+          _newArrowCheck(this, _this13);
 
           switch (type) {
             case 'on':
@@ -6584,20 +6639,20 @@
     }, {
       key: "resolveBoundAttributes",
       value: function resolveBoundAttributes(el) {
-        var _this13 = this;
+        var _this14 = this;
 
         var initialUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
         var extraVars = arguments.length > 2 ? arguments[2] : undefined;
         var attrs = getXAttrs(el);
         attrs.forEach(function (_ref2) {
-          var _this14 = this;
+          var _this15 = this;
 
           var type = _ref2.type,
               value = _ref2.value,
               modifiers = _ref2.modifiers,
               expression = _ref2.expression;
 
-          _newArrowCheck(this, _this13);
+          _newArrowCheck(this, _this14);
 
           switch (type) {
             case 'model':
@@ -6633,7 +6688,7 @@
               // If this element also has x-for on it, don't process x-if.
               // We will let the "x-for" directive handle the "if"ing.
               if (attrs.filter(function (i) {
-                _newArrowCheck(this, _this14);
+                _newArrowCheck(this, _this15);
 
                 return i.type === 'for';
               }.bind(this)).length > 0) return;
@@ -6654,10 +6709,10 @@
     }, {
       key: "evaluateReturnExpression",
       value: function evaluateReturnExpression(el, expression) {
-        var _this15 = this;
+        var _this16 = this;
 
         var extraVars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
-          _newArrowCheck(this, _this15);
+          _newArrowCheck(this, _this16);
         }.bind(this);
         return saferEval(expression, this.$data, _objectSpread2({}, extraVars(), {
           $dispatch: this.getDispatchFunction(el)
@@ -6666,10 +6721,10 @@
     }, {
       key: "evaluateCommandExpression",
       value: function evaluateCommandExpression(el, expression) {
-        var _this16 = this;
+        var _this17 = this;
 
         var extraVars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
-          _newArrowCheck(this, _this16);
+          _newArrowCheck(this, _this17);
         }.bind(this);
         return saferEvalNoReturn(expression, this.$data, _objectSpread2({}, extraVars(), {
           $dispatch: this.getDispatchFunction(el)
@@ -6678,12 +6733,12 @@
     }, {
       key: "getDispatchFunction",
       value: function getDispatchFunction(el) {
-        var _this17 = this;
+        var _this18 = this;
 
         return function (event) {
           var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
 
-          _newArrowCheck(this, _this17);
+          _newArrowCheck(this, _this18);
 
           el.dispatchEvent(new CustomEvent(event, {
             detail: detail,
@@ -6694,7 +6749,7 @@
     }, {
       key: "listenForNewElementsToInitialize",
       value: function listenForNewElementsToInitialize() {
-        var _this18 = this;
+        var _this19 = this;
 
         var targetNode = this.$el;
         var observerOptions = {
@@ -6703,9 +6758,9 @@
           subtree: true
         };
         var observer = new MutationObserver(function (mutations) {
-          var _this19 = this;
+          var _this20 = this;
 
-          _newArrowCheck(this, _this18);
+          _newArrowCheck(this, _this19);
 
           for (var i = 0; i < mutations.length; i++) {
             // Filter out mutations triggered from child components.
@@ -6714,14 +6769,14 @@
 
             if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'x-data') {
               (function () {
-                var _this20 = this;
+                var _this21 = this;
 
                 var rawData = saferEval(mutations[i].target.getAttribute('x-data'), {});
                 Object.keys(rawData).forEach(function (key) {
-                  _newArrowCheck(this, _this20);
+                  _newArrowCheck(this, _this21);
 
-                  if (_this19.$data[key] !== rawData[key]) {
-                    _this19.$data[key] = rawData[key];
+                  if (_this20.$data[key] !== rawData[key]) {
+                    _this20.$data[key] = rawData[key];
                   }
                 }.bind(this));
               })();
@@ -6729,9 +6784,9 @@
 
             if (mutations[i].addedNodes.length > 0) {
               mutations[i].addedNodes.forEach(function (node) {
-                _newArrowCheck(this, _this19);
+                _newArrowCheck(this, _this20);
 
-                if (node.nodeType !== 1) return;
+                if (node.nodeType !== 1 || node.__x_inserted_me) return;
 
                 if (node.matches('[x-data]')) {
                   node.__x = new Component(node);
@@ -6748,7 +6803,7 @@
     }, {
       key: "getRefsProxy",
       value: function getRefsProxy() {
-        var _this21 = this;
+        var _this22 = this;
 
         var self = this;
         var refObj = {};
@@ -6760,7 +6815,7 @@
         // we just loop on the element, look for any x-ref and create a tmp property on a fake object.
 
         this.walkAndSkipNestedComponents(self.$el, function (el) {
-          _newArrowCheck(this, _this21);
+          _newArrowCheck(this, _this22);
 
           if (el.hasAttribute('x-ref')) {
             refObj[el.getAttribute('x-ref')] = true;
@@ -6774,14 +6829,14 @@
 
         return new Proxy(refObj, {
           get: function get(object, property) {
-            var _this22 = this;
+            var _this23 = this;
 
             if (property === '$isAlpineProxy') return true;
             var ref; // We can't just query the DOM because it's hard to filter out refs in
             // nested components.
 
             self.walkAndSkipNestedComponents(self.$el, function (el) {
-              _newArrowCheck(this, _this22);
+              _newArrowCheck(this, _this23);
 
               if (el.hasAttribute('x-ref') && el.getAttribute('x-ref') === property) {
                 ref = el;
